{
    "status": 200,
    "message": "请求成功",
    "data": [
        {
            "id": "E54BF9F4-F187-450D-91B9-E9E14DD806E9",
            "categoryId": 9,
            "userID": "99CAA138-43C1-45D7-9F90-680FB25BCF8D",
            "likeNum": 1,
            "author": "turkeyaa",
            "isGood": 0,
            "authorImage": "8cccd292754f1545724239.6914082.jpg",
            "title": "Full Stack Developer",
            "viewNum": 61,
            "createTime": 1546567888,
            "collectNum": 0,
            "replyNum": 0,
            "content": "作者：顾鹏\n\n[链接：https://www.zhihu.com/question/22420900/answer/21770992](https://www.zhihu.com/question/22420900/answer/21770992)\n\n来源：知乎\n著作权归作者所有，转载请联系作者获得授权。\n\n> 做这样一个简单的 app:\n一个天气应用，干净清爽的界面，天气信息一目了然。它不仅可以精确预测未来 10 天的天气，还可以显示某地的历史天气信息。它具有自定义提醒功能，支持 web 版本， iOS 版， Android 版。\n\n###### 为什么想要做这样一个 App ？因为你喜欢旅行，但没找到一个天气 App 可以提供你下个月或者某个特定月份的天气信息；因为你懒你没有每天看天气预报的习惯，你想要在第二天温度达到 30 度以上或者温差有 +/-7 度的时候，获得温馨提示；因为你要成为一个 Full Stack Engineer ，你必须不断训练每个 stack 的能力。\n\n\n## Web版\n你决定用 MySql 来存储用户数据，用 NoSql 存储历史天气数据。你用 Redis 作为 cache ，缓存一些最常请求的天气数据。你用 Python 写后台，功能简单，后台不复杂，用户注册登录，抓取返回某城市的天气数据，某地的历史天气数据，很快便搞定。\n\n后台开发并测试好了，接下来是 Web 前端。你十分清楚一个好的 UI 设计对一个 App 的重要性，你也明白 UI 的设计不只是为了美观，更重要的是提高信息的可读性和程序的可用性。幸好你平日的积累这次派上用场了。你把之前保存下来的上百个优秀的UI设计作品拿来研究，你从书架上拿出Norman 的那本经典 - The Design of Everyday Things 重新细读。最终你用白纸黑笔敲定了第一个版本的 UI，简洁直观，没有任何多余的设计，所有元素的排列间距 大小颜色都恰到好处。你相信即使天气不好，但用户只要使用这个 App 都会有着愉悦的心情。\n\n那么开始写前端吧。啊，别急，都忘了还有 Icon 和 Logo ，可是不会 PS ，不会 AI ，不会 Sketch 怎么办呢，学吧。你平日喜欢结交不同领域的朋友，正好几周前在一个活动上你认识一位朋友做设计的。她花一个下午的时间教你基本的 Sketch 的使用，并对你的 UI 设计给出了一些意见。你请她吃了顿晚饭表示感谢，然后立即回家根据她的一些建议重新调整了 UI ，这次你在 PS 里把 UI 画了出来，Icons 和 Logo 也顺道一起做了。\n\n接下来的一周，你学习 HTML，CSS，以及 Javascript，并漂亮地把前端搞定。\n\n\n## 发布 App\n在朋友圈发了个状态，找人帮你做 Beta 测试。他们都首先问你是什么 App，一开始你简单回答一个天气的 App。但你发现，这不能提起他们的兴趣。你觉得你需要用语言，用故事包装一下。不光是作为别人「是什么 App」提问的回答，也是成为 Full stack Engineer 道路上的一个重要技能。\n\n你去看了所有你喜欢的产品的主页，从他们的文案上获得一些灵感启发；你读了经典的 On Writing Well ，发现好的文案，好的设计，其实和好的代码很相似，都是重在交流，如何让他人毫不费劲地明白你要表达的内容。你的故事要吸引人，你的产品介绍要在1分钟内解释清楚，并确保你的父母可以毫无压力听明白。\n\n一切就绪，产品上线了。反响不错，用户持续增加。很多用户希望有移动版本，于是你立即投入到iOS 版本的开发上。\n\n\n## iOS 版 及 后台优化\n\n你花一周不到时间学习了基本的语法和工具使用便投入到 App 的开发中。你知道 Learn by Doing 是最好也是最快的。由于之前学习了设计的基础，UI ，Icons 很快搞定，不久 iOS 版本便发布了。iOS 的发布带来了更多的用户增长，后台服务器的压力颇大，你知道是时候优化后台了。\n\n你在 AWS 上多开了 2 台服务器，并写了一个 Script 来自动化部署过程。\n你改用 uWSGi 协议，用 uwsgi 作为 Application Server。\n你使用 Nginx 来做并发，负载均衡 ...\n......\n......\n\n\n## 成立公司\n用户持续增长，每天你都会收到十几二十封用户的邮件。你很感激这些愿意花时间给你写邮件的用户，你相信他们是你最重要的用户，是潜在的付费用户。如果你把他们像上帝一样对待，他们同样也会把你看作是上帝。所以除了睡觉时间的发来的邮件，每一封邮件，你都会在2小时内给予回复。\n\n果然这样的付出是收获巨大的，他们不仅惊讶且非常感谢你的快速回复，他们会在app store里给你★★★★★的评价，他们在社交网站上分享你的app，他们甚至会主动提出捐款给你。\n\n你从快速的用户增长中嗅到了商机，你开始思考如何赚钱。广告你是坚决不能允许的，你认为再精确的广告也会影响用户体验。你设计了 2 个不同的付费方案，你打算用 A/B 测试看哪个方案更好。你分别给 200 个用户发去邀请尝试付费的邮件，邮件内容你精心打磨过，并在最后写上：CEO & Founder. 通过分析 2 种方案的用户行为，你决定将使用第一种方案。\n\n接下来，你相信差不多是时候成立个公司了。为了省时间，你花 2000 块钱找了个园区挂靠并帮你注册公司。公司的名字让你头疼了很久，你不想只是简单的用这个 App 的名字作为公司名字，你知道公司将来还会做出其他优秀的产品。你希望这个名字简单易记，同时其含义也是你公司文化的象征。\n\n公司注册下来了，但银行那边得自己跑。你联系了一些媒体编辑，邀请他们来试用你的产品；你重新设计了产品主页，并开始写产品的 Blog ；你在各大社交网络都给 App 注册了账号，即做社区客服也为宣传... 这些事大大压缩你写代码的时间。以往你都是以代码量作为衡量自己当天工作效率的指标，所以这些天你总感觉没做啥工作。\n\n这样的发展早已超过你的预期，这个 App 从一个 Side Project 几乎变成了你生活的全部。你跟你女朋友半个月才出去约会一次，她抱怨不断；你1个月没跟朋友出去玩耍喝酒了；你 2 个月都没锻炼过身体... 你意识到, YOU CAN NOT DO THIS ALONE，你需要帮手，你需要找人一起把这个做下去。\n\n但你不是要成为 Full Stack Engineer 么？你现在是了么？\n\n\n## Full Stack Engineer\n设计，后台开发，前端开发，移动开发，运营维护，PS，文案... 好像都会了，这算 Full Stack Engineer 了么？\n\n不，这只是踏上成为 Full Stack Engineer 的第一步。你知道目前只是每个 stack 都懂一点，离senior 或者 expert 还差得远，而要每个 stack 都做到极致，需要大量的时间和精力。精力有限，产品开发紧迫，力不从心啊，这条道路也太孤独，因为你不需要与任何人进行协作。难道要把一些stack的任务交给别人做么？这样算是放弃成为 Full Stack Engineer 么？\n\n不！这不是。\n什么是 Engineer？「Engineers are versatile minds who create links between science, technology, and society」。\nEngineer 的本质工作是设计，开发出应用于大众的产品。\n\n一个真正的 Full Stack Engineer ，他从生活中发现问题，洞察需求，他设计解决方案，并开发出初始版本的产品。为了达到目标，他愿意去学习任何领域的技能和知识。同时他不追求一个人完成所有工作，如果有人可以比他在某方面做得更出色，便会十分热情的邀请他们加入。\n\n最终他的职位也许不再是 Engineer ，他不再设计 UI ，不再写代码 ... 他的工作不再是 design and building an app or product，因为他有更大更重要的任务要做 - design and building a team or a company which builds great products. \n\n而这时，社会给了他们另一个称呼 - 创业者。尽管众人已忘记他们 Engineer 的身份，但在他们骨子里，内心深处，自己始终都是一个 Engineer 。当他们需要从头再来时，他们毫不犹豫从设计开发产品做起。Nikola Tesla，Ferdinand Porsche，Henry Ford，Jack Dorsey，Mark zuckerberg，Elon Musk ... 细数那些改变了或正改变世界的创业者，他们大多数是 Engineer 背景，热衷于设计创造。他们学习技能和知识，不是为了成为某个领域的专家；而是因为那些 是完成自己目标所需要的。\n\n\n以上，为我认可的 Full Stack Engineer\n\n\n[Full Stack Developer](https://www.zhihu.com/question/22420900)\n\n"
        },
        {
            "id": "0FBD55DD-AC62-4940-818A-47C908272B66",
            "categoryId": 2,
            "userID": "99CAA138-43C1-45D7-9F90-680FB25BCF8D",
            "likeNum": 0,
            "author": "turkeyaa",
            "isGood": 0,
            "authorImage": "8cccd292754f1545724239.6914082.jpg",
            "title": "Macdown基础教程",
            "viewNum": 6,
            "createTime": 1546567686,
            "collectNum": 0,
            "replyNum": 0,
            "content": "<!--标题-->\n# 标题\n## 标题\n### 标题\n#### 标题\n##### 标题\n###### 标题\n\n<!--有序列表-->\n1. Turkey\n2. Matt\n3. Jery\n\n<!--无序列表-->\n* 傻傻\n* 憧憧\n* 笨笨\n\n<!--引用-->\n> 这里是引用\n\n<!--图片-->\n![百度](http://mouapp.com/Mou_128.png)\n\n<!--链接-->\n[百度](http://wwww.baidu.com)\n\n<!--粗体-->\n**显示为粗体**\n\n<!--斜体-->\n*这里是斜体*\n\n<!--表格-->\n| Tables        | Are           | Cool  |\n| ------------- |:-------------:| -----:|\n| col 3 is      | right-aligned | $1600 |\n| col 2 is      | centered      |   $12 |\n| zebra stripes | are neat      |    $1 |\n\n<!--分割线-->\n***\n\n\t\n```ruby\nprint(\"Hello, world!\")\n```\n\n***\n***\n\n> 引用自掘金\n\n\n### 用掘金－Markdown 编辑器写文章\n\n欢迎使用 掘金－Markdown 编辑器撰写技术文章，只专注于内容和技术，不再费心排版的问题。这是一份简要的 Markdown 引导指南，希望可以帮助您顺利的开始使用 Markdown 编辑器。\n\n### 丰富的快捷键\n\n本 Markdown 编辑器支持丰富的格式快捷键，可以非常便捷、轻松的使用 Markdown 语言，形成优美的排版和内容格式。\n\n支持的快捷键有：\n\n* 加粗： `Ctrl/Cmd + B`\n* 标题： `Ctrl/Cmd + H`\n* 插入链接： `Ctrl/Cmd + K`\n* 插入代码： `Ctrl/Cmd + Shift + C`\n* 行内代码： `Ctrl/Cmd + Shift + K`\n* 插入图片： `Ctrl/Cmd + Shift + I`\n* 无序列表： `Ctrl/Cmd + Shift + L`\n* 撤销： `Ctrl/Cmd + Z`\n\n### 常用语法\n\n#### 标题\n\n> 语法格式：** '#'+'空格'+'文本' **\n\n# 一级标题\n## 二级标题\n### 三级标题\n#### 四级标题\n##### 五级标题\n###### 六级标题\n\n#### 列表\n\n> 无序列表语法格式：** '-' + '空格' ＋ '文本' **\n\n- 文本一\n- 文本二\n- 文本三\n\n> 有序列表语法格式：** '数字' + '.' + '空格' + '文本' **\n\n1. 文本一\n2. 文本二\n3. 文本三\n\n> 任务列表语法格式：** '-' + '空格' + '[ ]' + '文本' **\n\n- [x] 文本一\n- [ ] 文本二\n- [ ] 文本三\n\n#### 链接和图片\n\n在 Markdown 中插入链接不需要其他按钮，你只需要使用`［显示文本］(链接地址)`这样的格式语法即可。例如：\n[稀土掘金](https://gold.xitu.io)\n插入图片的语法与插入链接的语法很像，只是前面多了一个 `!`.语法如下：\n`![图片的标注](图片链接地址)`\n\n#### 引用\n\n> 语法：** '>'+'空格'+'文本' **\n\n\n例如：\n\n> Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。\n\n#### 代码\n\n如下是代码段的语法：\n\n<pre>\n```编程语言\n 这是代码段\n```\n</pre>\n\n例如：\n\n``` python\ndef bubbleSort(alist):\n for passnum in range(len(alist)-1,0,-1):\n #print alist,passnum\n for i in range(passnum):\n if alist[i]>alist[i+1]:\n temp = alist[i]\n alist[i] = alist[i+1]\n alist[i+1] = temp\n return alist\n```\n\n#### 表格\n\n**Markdown　Extra**　表格语法：\n\n项目 | 价格\n-------- | ---\niPhone | $560\niPad | $780\niMac | $1000\n\n可以使用冒号来定义对齐方式：\n\n| 项目 | 价格 | 数量 |\n| :-------- | --------:| :--: |\n| iPhone | 6000 元 | 5 |\n| iPad | 3800 元 | 12 |\n| iMac | 10000 元 | 234 |\n\n\n#### 结语\n\n以上是最常见的 Markdown 的语法和格式，如果你还希望深入的学习 Markdown，可以参考这里[Markdown语法](https://www.appinn.com/markdown/)，非常感谢使用** 掘金－Markdown 编辑器**,希望为您提供舒适的写作体验。\n\n"
        },
        {
            "id": "70A3B6F2-21D4-491C-A392-2B1ADD6672D8",
            "categoryId": 9,
            "userID": "99CAA138-43C1-45D7-9F90-680FB25BCF8D",
            "likeNum": 0,
            "author": "turkeyaa",
            "isGood": 0,
            "authorImage": "8cccd292754f1545724239.6914082.jpg",
            "title": "iOS开发，表单上传",
            "viewNum": 2,
            "createTime": 1546567507,
            "collectNum": 0,
            "replyNum": 0,
            "content": "\n2.3 HTTP POST 基本方法的实现\n\n```\n- (NSURLRequest *)HTTPPOSTNormalRequestForURL:(NSURL *)url parameters:(NSDictionary *)parameters\n{\n     NSMutableURLRequest *URLRequest = [[NSMutableURLRequestalloc]initWithURL:urlcachePolicy:NSURLRequestReloadIgnoringLocalCacheDatatimeoutInterval:TIME_OUT_INTERVAL];\n   NSString *HTTPBodyString = [selfHTTPBodyWithParameters:parameters];\n    [URLRequest setHTTPBody:[HTTPBodyStringdataUsingEncoding:NSUTF8StringEncoding]];\n    [URLRequestsetHTTPMethod:@\"POST\"];\n   return URLRequest;\n    \n}\n```\n\n这个和GET极其类似，只不过是把请求参数放在了HTTPBody中了。\n2.4 HTTP POST Multipart\n\n```\n- (NSURLRequest *)HTTPPOSTMultipartRequestForURL:(NSURL *)url parameters:(NSDictionary *)parameters\n{\n    NSMutableURLRequest *URLRequest = [[NSMutableURLRequestalloc]initWithURL:urlcachePolicy:NSURLRequestReloadIgnoringLocalCacheDatatimeoutInterval:TIME_OUT_INTERVAL];\n    \n    NSString *contentType = [NSStringstringWithFormat:@\"multipart/form-data;boundary=%@\",SR_POST_BOUNDARY];\n// 设置内容的类型 contentType，这完全是按照POST的格式来设置\n    [URLRequestsetValue:contentType forHTTPHeaderField:@\"Content-Type\"];\n    [URLRequestsetHTTPMethod:@\"POST\"];\n    [URLRequest setHTTPBody:[selfHTTPPOSTMultipartBodyWithParameters:parameters]];\n   return URLRequest;\n}\n\n```\n\n用于创建Multipart Body，需要分割线，也是完全参考POST格式\n\n```\n- (NSData *)HTTPPOSTMultipartBodyWithParameters:(NSDictionary *)parameters\n{\n    NSMutableData *body = [NSMutableDatadata];\n    \n    // Add Body Prefix String\n    [body appendData:[[NSStringstringWithFormat:@\"--%@\\r\\n\",SR_POST_BOUNDARY]dataUsingEncoding:NSUTF8StringEncoding]];\n    \n    // Add Main Body\n   for (NSString *keyin [parametersallKeys]) {\n       id value = [parameters objectForKey:key];\n        \n       if ([value isKindOfClass:[NSStringclass]]){\n            [body appendData:[[NSStringstringWithFormat:@\"Content-Disposition: form-data; name=\\\"%@\\\"\\r\\n\\r\\n%@\\r\\n\",key,value]dataUsingEncoding:NSUTF8StringEncoding]];\n            [body appendData:[[NSStringstringWithFormat:@\"--%@\\r\\n\",SR_POST_BOUNDARY]dataUsingEncoding:NSUTF8StringEncoding]];\n        }else {\n            NSLog(@\"please use addMultiPartData:withName:type:filename: Methods to implement\");\n        }\n    }\n   return body;\n}\n\n```\n\n在最后要附加上请求参数中的图片等等大的数据！\n\n```\n- (void)addMultiPartData:(NSData *)data\n                withName:(NSString *)name\n                    type:(NSString *)type\n                filename:(NSString *)filename\n{\n   NSMutableURLRequest *URLRequest = [self.URLRequestmutableCopy];\n   NSMutableData *body = [URLRequest.HTTPBodymutableCopy];\n    \n    // Step 1\n   NSString *disposition = [[NSStringalloc]init];\n   if (!filename) {\n        disposition =\n        [NSStringstringWithFormat:@\"Content-Disposition: form-data; name=\\\"%@\\\"; filename=\\\"%@\\\"\\r\\n\", name, filename];\n    }else {\n        disposition =\n        [NSStringstringWithFormat:@\"Content-Disposition: form-data; name=\\\"%@\\\"; filename=\\\"%@\\\"\\r\\n\", name, name];\n    }\n    [body appendData:[dispositiondataUsingEncoding:NSUTF8StringEncoding]];\n    \n    // Step 2\n   NSString *contentType = [NSStringstringWithFormat:@\"Content-Type: %@\\r\\n\\r\\n\",type];\n    [body appendData:[contentTypedataUsingEncoding:NSUTF8StringEncoding]];\n    \n    // Step 3\n    [bodyappendData:data];\n    \n    // Step 4 Add suffix boundary\n   NSString *boundary = [NSStringstringWithFormat:@\"\\r\\n--%@--\\r\\n\",SR_POST_BOUNDARY];\n    [body appendData:[boundarydataUsingEncoding:NSUTF8StringEncoding]];\n    \n    // Step 5\n    [URLRequestsetHTTPBody:body];\n   self.URLRequest = URLRequest;\n}\n\n```\n\n3、下面说一下接受数据\n一般我们要把NSData数据变成JSON数据，大都是情况下获得的JSON Object是NSDictionary或NSArray\n基本方法是\n\n```\nid receivedData = [NSJSONSerializationJSONObjectWithData:dataoptions:NSJSONReadingMutableContainers|NSJSONReadingMutableLeaveserror:nil];\n然后就可以进行相关的处理了！\n\n\n\n--0xKhTmLbOuNdArY\nContent-Disposition: form-data; name=\"fb_title\"\n\nHello\n\n--0xKhTmLbOuNdArY\nContent-Disposition: form-data; name=\"fb_content\"\n\nThis is test opinion\n\n--0xKhTmLbOuNdArY\nContent-Disposition: form-data; name=\"fb_contact\"\n\n18668089860@163.com\n\n--0xKhTmLbOuNdArY\nContent-Disposition: form-data; name=\"fb_img\"; filename=\"AuthorImg.png\"\nContent-Type: image/jpge,image/gif, image/jpeg, image/pjpeg, image/pjpeg\n\n```\n\n"
        },
        {
            "id": "1B3A54E1-ACF1-451E-9FDE-69B297CF4551",
            "categoryId": 3,
            "userID": "99CAA138-43C1-45D7-9F90-680FB25BCF8D",
            "likeNum": 2,
            "author": "turkeyaa",
            "isGood": 0,
            "authorImage": "8cccd292754f1545724239.6914082.jpg",
            "title": "iOS框架搭建",
            "viewNum": 46,
            "createTime": 1545723922,
            "collectNum": 1,
            "replyNum": 4,
            "content": "# Objective-C 项目实战\n\n> 面向对象编程三大特性：封装、继承、多态，这篇文章会在实际项目编码中介绍这些特性，提高编码水平和质量。\n\n> 根据实际项目开发总结，旨在让我们更加快速、高效的开发移动app\n\n1. 目录结构\n2. 接口封装\n3. 界面封装\n4. 模型封装\n5. 组件封装\n6. 对象组合\n7. 宏定义、工具类\n\n![动图](Resource/TemplateCocoa.gif)\n\n`功能列表`\n\n### 包含不限于下列功能：\n\n1. UIViewController控制器封装(包含：BaseVC、BaseWebVC、BaseTC、BaseLoadTC、BaseFormTC、BaseFormGroupTC、BaseSwipeVC、BaseNavSwipeVC)。支持导航栏标题和图标设置、自定义导航栏、左右标题事件、HUD功能、空页面提示和交互功能、html5页面访问功能、表视图控制器功能、自定义约束、下拉刷新和上拉加载交互功能、表单和分组表视图控制器功能、仿新闻多视图切换控制器功能、导航多视图切换控制器功能。查看`Common/VC`目录\n2. 接口封装(包含：RestApi、BaseRestApi、API_UnitTest、Login_Post......等)。自定义网络库，支持同步和异步访问接口、取消任务、配置路径和参数、模拟本地接口、数据解析和回调。查看`API`目录\n3. UITableViewCell界面封装(包含：TCell_Image、TCell_Input、TCell_Label、TCell_Notify...等)，可以扩展新的组件。支持图片、输入框、通知、文本的表单元格式，每个Cell都是一个独立的组件，封装了各自的交互逻辑。查看`Common/Cell`和`Common/Kit/Table view cell`目录\n4. 模型封装(JSONModel)，支持模型和JSON的相互转化，也可以使用第三方库(YYModel、MJExtension)。查看`Model`目录\n5. 组件封装(包含：表单元、空视图、导航栏、多标题视图......等)，你可以扩展新的组件。查看`Common/Kit`目录\n6. 服务模块(包含：Workspace、FileManager...等)。支持用户管理、APP配置管理、远程配置管理、数据库访问、日期管理、正则表达式、运行时系统、Action接口管理、谓词...等接口封装，基于外观模式设计。访问`Service`目录\n7. 基于`WKWebView`类，JavaScript和原生数据交互\n8. 宏定义、枚举、block定义\n9. 动画，基于`CAAnimation`和`UIBezierPath`的购物车动画\n10. 设计模式：单例模式、适配器模式、外观模式、对象去耦(中介者和观察者模式)、组合模式、模板方法...等设计模式的使用。[个人总结的iOS开发设计模式](https://www.jianshu.com/p/f4f8318d51c9)\n11. 基于Swift语言的项目实战[TemplateSwiftAPP](https://github.com/turkeyaa/TemplateSwiftAPP)\n\n### TODO\n\n1. 基于上传图片基类：`BaseUploadApi`，支持一张和多张图片的上传\n2. 工具类、开发技巧\n3. 基于Vapor服务端项目实战[SwiftCN](https://github.com/SwiftCN/SwiftCN)\n\n***\n\n#### 1. 目录结构图\n![目录结构图](Resource/Structure.png)\n\n##### 说明\n\n* APIs：包含所有的接口调用，每个接口都包装成一个单独的类。处理数据的解析、回调、传值、统计分析、错误日志、错误码\n* Common：封装界面相关的类，比如BaseVC、BaseTC、BaseView、BaseTCell...等\n* Image：本地图片资源\n* Macro：定义常量、枚举、block...等\n* Model：定义模型\n* Resource：本地 json 数据，模拟本地接口\n* Service：单例类、工具类...等\n* Vendors：自定义第三方工具插件\n* VCs：新功能模块开发\n* Images.xcassets：切图资源\n* PrefixHeader.pch：编译预引用头文件\n* Pods：第三方库\n\n***\n\n#### 2. 接口封装\n\n> 一般的我们会使用第三方插件(AFNetworking...)来处理网络请求，每个请求都是通过AFN来调用，这样不好是因为开发和维护都需要很多的工作量。而有写经验的开发者会考虑在基类中实现AFN接口，通过继承的方式来处理网络请求，这样就很好了。下面介绍如何打造自己的网络库。\n\n![](http://turkeyaa.github.io/assets/2015/MVC.png)\n\n#### 在ViewController中，登录接口就是这样：\n\n```\n// 在 LoginVC.m 中实现登录\nLogin_Post *loginApi = [[Login_Post alloc] initWithAccount:account password:password];\n[loginApi call];\n\nif (loginApi.code == RestApi_OK) {\n\t// 登录成功，赋值，其他处理....\n\tUserInfo *userInfo = loginApi.userInfo;\n\n}\nelse {\n\t// 登录失败\n\t[self showErrorMessage:loginApi.errorMessage];\n}\n```\n\n\n#### 一般的网络请求方法步骤：\n\n```\n// 1. 创建url\nNSString *urlStr = @\"http://192.169.1.88/loging?account=turkey&password=123456\";\nNSURL *url = [NSURL URLWithString:urlStr];\n\n// 2. 创建请求\nNSURLRequest *request = [NSURLRequest requestWithURL:url];\n\n// 3. 创建会话（这里使用了一个全局会话）\nNSURLSession *session = [NSURLSession sharedSession];\n\n// 4. 通过会话创建任务\nNSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request \n\t\tcompletionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n\tif (!error) {\n\t\tNSString *dataStr = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];\n\t\tNSLog(@\"%@\",dataStr);\n\t}else{\n\t\tNSLog(@\"error is :%@\",error.localizedDescription);\n\t}\n}];\n\n// 5. 每一个任务默认都是挂起的，需要调用 resume 方法启动任务\n[dataTask resume];\n\n```\n\n#### 这些方法是通用的，不同的只是参数、请求方式(GET/POST/PUT...)、接口路径、返回的数据。那我们是不是可以把不同的参数通过多态(重写父类的方法)来实现。而请求数据完成，通过block、代理或重载来处理不同的结果。这里的结果一般的是json数据，同时就可以把json转换成model传递给相应的控制器对象。你会发现我们的请求过程会特别的简单、方便。流程图：\n\n#### 如何实现？\n\n1. 定义RestApi，一个抽象类。包含：初始化、执行、取消、结果处理、参数...等方法。一些是子类必须要实现的方法(参数、结果处理)\n2. 定义BaseRestApi，继承RestApi。定义错误码和结果处理方法\n3. 定义Login_Post，继承BaseRestApi。定义初始化方法、请求参数、处理结果方法\n\n#### 在RestApi，中实现网络请求、回调，也可以处理一些统计分析、异常等处理。在BaseRestApi中会有相应的错误码，是否成功，提示客户。在LoginApi中得到回调，并解析，传递给相应的控制器。\n\n```\n// 1. 定义一个枚举，请求方式\ntypedef NS_ENUM(NSInteger, HttpMethods) {\n\tHttpMethods_Get = 1,\n\tHttpMethods_Post = 2,\n\tHttpMethods_Delete = 3,\n\tHttpMethods_Put = 4,\n};\n\n// 2. 初始化方法\n- (id)initWithURL:(NSString *)url httpMethod:(HttpMethods)httpMethod;\n\n// 3. 执行和取消\n- (void)call:(BOOL)async;\n- (void)cancel;\n\n// 3. 参数：Get、Post方式，\n- (NSData *)requestData;                // Post\n- (NSDictionary *)queryParameters;      // Get\n\n// 4. 回调，需要子类重写\n- (void)onSuccessed;\n- (void)onFailed;\n- (void)onCancelled;\n- (void)onTimeout;\n- (void)onError:(NSError *)error;\n\n```\t\t\n\n#### 重点是 call：方法\n\n```\n// 1. 数据请求必须在异步线程中\nif ([NSThread isMainThread] && !async) {\n\t[self raiseException:@\"主线程不允许同步调用\"];\n\treturn;\n}\n\n// 2. 初始化request\nNSMutableURLRequest *request = [[NSMutableURLRequest alloc] init];\n\n// 3. 在GET请求中我的接口是：http://192.169.1.88/loging?account=turkey&password=123456\"。而POST请求接口：http://192.169.1.88/loging，参数方式不同。\nif (_httpMethod == HttpMethods_Get) {\n\nNSMutableString *strUrl = [[NSMutableString alloc] initWithString:_url];\n\n@try {\n\tNSDictionary *params = [self queryGetParameters];\n\tif (params) {\n\n\t// Get 参数\n\tNSArray *keys = params.allKeys;\n\n\tfor (int i = 0; i< keys.count; i++) {\n\t\tNSString* key = [keys objectAtIndex:i];\n\t\tNSString* value = [params valueForKey:key];\n\n\t\tif (i == 0) {\n\t\t\t[strUrl appendString:@\"?\"];\n\t\t} else {\n\t\t\t[strUrl appendString:@\"&\"];\n\t\t}\n\t\t[strUrl appendString:key];\n\t\t[strUrl appendString:@\"=\"];\n\t\t[strUrl appendString:[NSString stringWithFormat:@\"%@\", value]];\n\t\t}\n\t}\n\n\t[request setURL:[NSURL URLWithString:strUrl]];\n\t[request setHTTPMethod:@\"GET\"];\n\t[request setTimeoutInterval:timeout];\n\n\t} @catch (NSException *exception) {\n\n\t} @finally {\n\n\t}\n}\n\n\telse if (_httpMethod == HttpMethods_Post) {\n\t\t[request setURL:[NSURL URLWithString:_url]];\n\t\t[request setHTTPMethod:@\"POST\"];\n\t\t[request setValue:@\"application/json\" forHTTPHeaderField:@\"Content-Type\"];\n\t\tNSData *postData = [self queryPostData];\n\t\t[request setHTTPBody:postData];\n\t}\nelse {\n\tNSAssert(NO, @\"目前只支持 GET、POST 请求方式\");\n}\n\nNSLog(@\"url = %@\",_url);\n\n__weak RestApi *weakSelf = self;\n\n// 4. 这里通过条件来实现线程同步\n\tNSCondition *condition = [[NSCondition alloc] init];\n\n\tNSURLSession *session = [NSURLSession sharedSession];\n\n\t_task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {\n\n\tif (error) {\n\n\t\t[weakSelf doFailure:error];\n\t}\n\telse {\n\t\t[weakSelf doSuccess:data];\n\t}\n\t\n\t[condition lock];\n\t[condition signal];\n\t[condition unlock];\n}];\n\n// 5. 开始请求\n[_task resume];\n\nif (condition) {\n\t[condition lock];\n\t[condition wait];\t\t\t\n\t[condition unlock];\n}\n```\n\n#### 在BaseRestApi中，需要重写queryPostData:\n\n```\n\nid requestData = [self prepareRequestData];\n\nif ([requestData isKindOfClass:NSData.class]) {\n\treturn requestData;\n}\nif ([requestData isKindOfClass:NSDictionary.class]) {\n\tNSMutableDictionary* dict = [NSMutableDictionary dictionaryWithDictionary:requestData];\n\tNSData * jsondata=[NSJSONSerialization dataWithJSONObject:dict options:NSJSONWritingPrettyPrinted error:nil];\n\treturn jsondata;\n}\nif ([requestData isKindOfClass:NSArray.class]) {\n\n\tNSMutableArray *array = [NSMutableArray arrayWithArray:requestData];\n\tNSData *jsondata = [NSJSONSerialization dataWithJSONObject:array options:NSJSONWritingPrettyPrinted error:nil];\n\treturn jsondata;\n}\nif ([requestData isKindOfClass:NSString.class]) {\n\treturn [((NSString*)requestData) dataUsingEncoding:NSUTF8StringEncoding];\n}\nreturn nil;\n\t\t\n```\n\n#### 还有 doSuccess: 方法\n\n```\n// 1. 调用的哪个接口，返回的json数据，方便调试用\nNSLog(@\"RestApi :[%@]\",self.class);\nNSLog(@\"RestApi Response:[%@]\",[[NSString alloc] initWithData:responseObject encoding:NSUTF8StringEncoding]);\n\n// 2. 解析数据\n@try {\n\tNSError *error;\n\tNSDictionary *json = [NSJSONSerialization JSONObjectWithData:responseObject options:NSJSONReadingAllowFragments error:&error];\n\tself.code = [json[@\"status\"] integerValue];\n\tself.message = json[@\"message\"];\n\n\tif (self.code == RestApi_OK && [self parseResponseJson:json]) {\n\t\t[self onSuccessed];\n\t}\n\telse {\n\t\tif (self.code == RestApi_OK) {\n\n\t\t\t[self onSuccessed];\n\t}\n\telse {\n\t\t[self onFailed];\n\t\t}\n\t}\n\n} @catch (NSException *exception) {\n\t[self onError:nil];\n} @finally {\n\n}\n\t\t\n```\n\n#### 在 Login_Post中，重写parseResponseJson：、prepareRequestData方法(如果的GET请求：queryParameters)\n\n```\n// 解析\n- (BOOL)parseResponseJson:(NSDictionary *)json {\n\n\tNSDictionary *data = json[@\"data\"];\n\tif (data) {\n\t\t// 这里处理登录成功返回的JSON数据, 这里使用YYModel库\n\t\tself.userInfo = [UserModel yy_modelWithJSON:data];\n\t}\n\n\treturn self.userInfo && self.userInfo.user_id.length > 0;\n}\n\n// POST 请求\n- (id)prepareRequestData {\n\treturn @{\n\t\t@\"user_account\":_account,\n\t\t@\"user_pwd\":[URLUtil base64Encode:_password]\n\t};\n}\n\n// GET 请求是这样\n- (NSDictionary *)queryParameters {\n\treturn @{\n\t\t@\"email\":_email\n\t};\n}\n\n```\n***\n\n#### 3. 界面封装\n\n#### 重点介绍**UIViewController**和**UITableViewCell**的封装\n\n#### UIViewController的继承关系，设计如下图：\n\n![BaseVC继承关系图](http://turkeyaa.github.io/assets/2017/BaseLoadTC.png)\n\n#### 在BaseVC.h中，定义了一些属性和方法，包括：是否显示导航条、左标题、右标题、左图标、右图标、左条目事件、右条目事件、HUD的显示和隐藏。基本上满足了对控制器对象的基本的交互封装。\n\n#### 在BaseTC中，这是一个带有UITableView的视图控制器。包括：一个NSMutableArray类型的数据源和UITableView类型的表视图对象。\n\n#### 在BaseLoadTC中，这是一个带有下拉刷新、加载更多和表视图的视图控制器对象。\n\n#### 在我们的视图控制器中，就可以这样写：\n\n```\n// 显示标题\nself.leftTitle = @\"登录\";\nself.rightTitle = @\"注册\";\n\t\n// 或者显示图标\nself.leftImage = [UIImage imageNamed:@\"app_icon\"];\nself.rightImage = [UIImage imageNamed:@\"app_icon\"];\n\t\n// 显示HUD\n[self showLoadingHUD];\n// 自定义HUD\n[self showLoadingHUD:@\"正在登录中...\"];\n// 隐藏HUD\n[self hideLoadingHUD];\n// 成功、失败、错误...等\n[self showSuccessMessage:@\"加载成功\"];\n[self showErrorMessage:@\"加载失败\"];\n[self showInfoMessage:@\"其他失败\"];\n\n// 空页面\nself.isShowEmptyView = YES;\n\n/** 可选，子类已实现 */\n- (UIImage *)baseEmptyImage {\n    return [UIImage imageNamed:@\"app_emptyView\"];\n}\n- (NSString *)baseEmptyTitle {\n    return @\"暂无内容\";\n}\n- (NSString *)baseEmptySecondTitle {\n    return @\"暂无子标题\";\n}\n- (void)baseEmptyRefresh {\n    [self showLoadingHUD:@\"刷新空页面\"];\n    [GCDUtil runInGlobalQueue:^{\n        sleep(1);\n        [GCDUtil runInMainQueue:^{\n            [self showSuccessMessage:@\"刷新成功\"];\n            self.isShowEmptyView = NO;\n        }];\n    }];\n}\n\n\n```\n\n#### BaseTCell类设计如下：\n\n![BaseTCell继承关系](http://turkeyaa.github.io/assets/2017/BaseTCell.png)\n\n#### 通过 **tcell:reuse:** 方法来初始化UITableViewCell对象，支持 **click** 监听点击事件、**showIndicator** 是否显示右边的箭头、重写 **classCellHeight** 重写子类的高度、重写 **setupSubViews** 自定义子类界面。\n\n#### 然后我们的表视图数据源方法中 **tableView: cellForRowAtIndexPath:** ，初始化表视图就是这样：\n\n```\n- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {\n    \n\tMainCell *cell = [MainCell tcell:self.tableView reuse:YES];\n\tMainInfo *info = self.dataSource[indexPath.row];\n\tcell.mainInfo = info;\n\tcell.showIndicator = YES;\t\t// 默认为YES\n    \n\treturn cell;\n}\n\t\n```\n\t\n#### 你也可以自定义UITableViewCell的高度：\n\n```\n- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath {\n\treturn [MainCell classCellHeight];\n}\n\t\n```\n***\t\n\n#### 4. 模型封装\n\n#### 对象模型对象，最基本的需要满足下面的功能：\n1. JSON和Model的相互转化\n2. 编码和解码\n3. 对象的深复制\n\n#### 一般的我们使用**MJExtension**来处理模型转化，基本上可以项目中的各种需求。如果让你自己来实现这些功能，该如何来设计？\n\n#### 定义JSONModel类，继承NSObject类。实现NSCopying,NSCoding,NSMutableCopying三个协议。支持编码和解码功能，两个类方法，支持JSON和Model的相互转化。\n\n> 代码清单 JSONModel.h\n\t\n```\n@interface JSONModel : NSObject <NSCopying,NSCoding,NSMutableCopying>\n\n+ (id)jsonModelWithDictionary:(NSDictionary *)jsonDict;\n+ (NSDictionary *)jsonModelWithModel:(JSONModel *)model;\n\n@end\n\t\n```\n\t\n> 代码清单 JSONModel.m\n\t\n```\n// 基于运行时特性，动态获取类的属性\n#import \"NSObject+Property.h\"\n\t\n- (id)initWithDictionary:(NSDictionary *)jsonDict {\n\tif (self = [super init]) {\n\t\t[self setValuesForKeysWithDictionary:jsonDict];\n\t}\n\treturn self;\n}\n\n+ (id)jsonModelWithDictionary:(NSDictionary *)jsonDict {\n\tJSONModel *model = [[self alloc] initWithDictionary:jsonDict];\n\treturn model;\n}\n\n+ (NSDictionary *)jsonModelWithModel:(JSONModel *)model {\n    \n\tNSMutableDictionary *dict = [[NSMutableDictionary alloc] init];\n    \n\tNSArray *properNames = [model getPropertyList];\n    \n\tfor (NSString *key in properNames) {\n        \n\t\tid value = [model valueForKey:key];\n\t\tif (value) {\n\t\t\t[dict setValue:value forKey:key];\n\t\t}\n\t}\n\treturn dict;\n}\n\t\n```\n\n#### 在 **jsonModelWithDictionary:** 方法中，基于KVC特性，把JSON转化成MOdel对象，在 **jsonModelWithModel:** 方法中，在运行时获取model的属性类型(runtime机制)，然后根据属性获取属性值(KVC机制)，然后把属性和值添加到字典中。即可实现Model转化成JSON字典对象。\n\n> 代码清单，接上，JSONModel.m\n\t\n```\n#pragma mark -\n#pragma mark - NSCoding协议:解码\n- (id)initWithCoder:(NSCoder *)aDecoder {\n    \n\tif (self = [super init]) {\n        \n\t\tNSArray *properNames = [self getPropertyList];\n        \n\t\tfor (NSString *key in properNames) {\n            \n\t\t\tid varValue = [aDecoder decodeObjectForKey:key];\n\t\t\tif (varValue) {\n\t\t\t\t[self setValue:varValue forKey:key];\n\t\t\t}\n\t\t}\n\t}\n\treturn self;\n}\n\t\n#pragma mark -\n#pragma mark - NSCoding协议:编码\n- (void)encodeWithCoder:(NSCoder *)aCoder {\n\tNSArray *properNames = [self getPropertyList];\n\tfor (NSString *key in properNames) {\n        \n\t\tid varValue = [self valueForKey:key];\n\t\tif (varValue)\n\t\t{\n\t\t\t[aCoder encodeObject:varValue forKey:key];\n\t\t}\n\t}\n}\n\n#pragma mark -\n#pragma mark - NSCopying协议\n- (id)mutableCopyWithZone:(NSZone *)zone {\n\t// subclass implementation should do a deep mutable copy\n\t// this class doesn't have any ivars so this is ok\n\tJSONModel *newModel = [[JSONModel allocWithZone:zone] init];\n\treturn newModel;\n}\n\n- (id)copyWithZone:(NSZone *)zone {\n\t// subclass implementation should do a deep mutable copy\n\t// this class doesn't have any ivars so this is ok\n\tJSONModel *newModel = [[JSONModel allocWithZone:zone] init];\n\treturn newModel;\n}\n\t\n```\n\n***\n\n> 客户端代码\n\t\n```\n// json转化成model 和 model 转化成 json\nMainInfo *info = [MainInfo jsonModelWithDictionary:dict];\nNSDictionary *dict = [MainInfo jsonModelWithModel:info];\n\t\n// 编码\nMainInfo *p = [[MainInfo alloc] init];\np.name = @\"turkey\";\nNSString *documents = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];\nNSString *path = [documents stringByAppendingPathComponent:@\"main.archiver\"];//拓展名可以自己随便取\n[NSKeyedArchiver archiveRootObject:p toFile:path];\n\t    \n// 解码\nNSString *documents = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];\nNSString *path = [documents stringByAppendingPathComponent:@\"main.archiver\"];\nMainInfo *mainInfo = [NSKeyedUnarchiver unarchiveObjectWithFile:path];\n\t\n```\t\n\n#### 5. 组件封装\n\n![效果图](Resource/Kit.png)`效果图`\n\n##### 上面包含了五种Cell，每个Cell都是独立的模块，并且完成各自的功能和交互逻辑。如：图片、文字、通知、输入框等功能。每个组件之间通过接口来访问\n\n##### 如何实现？\n\n首先定义了基类：**BaseTCell**，定义了通用的接口，然后在子类中来设计特定的实现。\n\n接口定义如下：\n\n```\n@class BaseTCell;\n\ntypedef void(^ClickEventBlock)(NSIndexPath *indexPath, BaseTCell *cell);\n\n@interface BaseTCell : UITableViewCell\n\n+ (CGFloat)classCellHeight;\n\n+ (instancetype)tcell:(UITableView *)tableView reuse:(BOOL)reuse;\n\n@property (nonatomic, weak) UITableView *tableView;\n@property (nonatomic, assign) BOOL showIndicator;\n@property (nonatomic, strong) ClickEventBlock click;\n\n- (CGFloat)height;\n\n- (void)setupUI;\n\n- (void)scrollToActiveTextField;\n\n#pragma mark - Subclass\n- (void)setupSubViews;\n- (void)setupLayout;\n\n@end\n\n```\n\n然后在子类中，实现相应的逻辑。比如：**TCell_Input**类，该类实现了输入框的交互逻辑。支持手机号、密码、符号的输入，同时实现了键盘的点击背景的隐藏事件、最大输入长度、颜色、图标......等。\n\n接口设计如下：\n\n```\n@interface TCell_Input : BaseTCell\n\n/** 图片 */\n@property (nonatomic, strong) UIImage *icon;\n/** 标题 */\n@property (nonatomic, strong) NSString *title;\n/** 标题颜色 */\n@property (nonatomic, strong) UIColor *titleColor;\n/** 输入框文本 */\n@property (nonatomic, strong) NSString *text;\n/** 输入框占位符 */\n@property (nonatomic, strong) NSString *placeholder;\n\n/** 支持可输入的最大长度，默认为11 */\n@property (nonatomic, assign) NSInteger limitMaxLength;\n\n/** 输入框类型：字符 */\n+ (instancetype)stringInputCell;\n/** 输入框类型：数字 */\n+ (instancetype)numberInputCell;\n/** 输入框类型：密码 */\n+ (instancetype)passwordInputCell;\n\n@end\n\n```\n\n客户端代码如下：\n\n```\nWEAKSELF\n    _cellUser = [TCell_Image tcell:self.tableView reuse:NO];\n    _cellUser.icon = [UIImage imageNamed:@\"s_info\"];\n    _cellUser.title = @\"设置\";\n    _cellUser.value = @\"详情\";\n    \n    _cellVersion = [TCell_Image tcell:self.tableView reuse:NO];\n    _cellVersion.icon = [UIImage imageNamed:@\"s_setting\"];\n    _cellVersion.title = @\"版本\";\n    _cellVersion.value = @\"V1.0\";\n    \n    _cellAbout = [TCell_Image tcell:self.tableView reuse:NO];\n    _cellAbout.icon = [UIImage imageNamed:@\"s_notify\"];\n    _cellAbout.title = @\"消息\";\n    _cellAbout.value = @\"更多消息\";\n    _cellVersion.hasMsg = YES;\n    \n    // 多视图控制器切换(支持空页面)\n    _cellNews = [TCell_Image tcell:self.tableView reuse:NO];\n    _cellNews.icon = [UIImage imageNamed:@\"s_notify\"];\n    _cellNews.title = @\"新闻\";\n    _cellNews.click = ^(NSIndexPath *indexPath, BaseTCell *cell) {\n        [weakSelf gotoNewsVC];\n    };\n    _cellMessages = [TCell_Image tcell:self.tableView reuse:NO];\n    _cellMessages.icon = [UIImage imageNamed:@\"s_notify\"];\n    _cellMessages.title = @\"消息\";\n    _cellMessages.click = ^(NSIndexPath *indexPath, BaseTCell *cell) {\n        [weakSelf gotoMessageVC];\n    };\n    \n    _nameCell = [TCell_Input stringInputCell];\n    _nameCell.icon = [UIImage imageNamed:@\"business_nor\"];\n    _nameCell.title = @\"姓名\";\n    _nameCell.showIndicator = NO;\n    _nameCell.limitMaxLength = 12;\n    _nameCell.placeholder = @\"请输入姓名\";\n    \n    _cardCell = [TCell_Input numberInputCell];\n    _cardCell.title = @\"身份证\";\n    _cardCell.showIndicator = NO;\n    _cardCell.limitMaxLength = 20;\n    _cardCell.placeholder = @\"请输入身份证号码\";\n    \n    _notifyCell =  [TCell_Notify tcell:self.tableView reuse:YES];\n    _notifyCell.title = @\"通知\";\n    _notifyCell.showIndicator = NO;\n    _notifyCell.isNotifyOpened = NO;\n    [_notifyCell addSwitchTarget:self selector:@selector(switchEvent:)];\n    \n    _networkCell = [TCell_Notify tcell:self.tableView reuse:YES];\n    _networkCell.title = @\"WIFI\";\n    _networkCell.showIndicator = NO;\n    _networkCell.isNotifyOpened = YES;\n    [_networkCell addSwitchTarget:self selector:@selector(switchEvent:)];\n    \n    _emptyCell = [TCell_Label tcell:self.tableView reuse:YES];\n    _emptyCell.title = @\"空页面\";\n    _emptyCell.value = @\"测试空页面\";\n    _emptyCell.click = ^(NSIndexPath *indexPath, BaseTCell *cell) {\n        [weakSelf gotoEmptyVC];\n    };\n    \n    self.cells = @[@[_cellUser],@[_cellAbout,_cellVersion],@[_cellNews,_cellMessages],@[_notifyCell,_networkCell],@[_nameCell,_cardCell],@[_emptyCell]];\n    \n```\n\n#### 6. 对象组合\n\n> 组合模式：将对象组合成树形结构以表示”部分-整体”的层次结构。组合使得用户对单个对象和组合对象的使用具有一致性\n\n![对象组合模式](https://turkeyaa.github.io/assets/2015/design/Composite.png)\n\n基接口是定义了`Leaf`类和`Composite`类的共同操作的Component\n\n每个节点代表一个叶节点或组合体节点。`Leaf`节点与`Composite`节点的主要区别在于，`Leaf`节点不包含同类型的子节点，而`Composite`则包含。`Composite`包含同一类型的子节点。由于`Leaf`类与`Composite`类有同样的接口，任何对`Component`类型的操作也能安全地应用到`Leaf`和`Composite`。客户端就不需要根据确切类型的is-else语句\n\n`Composite`需要方法来管理子节点，比如`add:component`和`remove:component`。因为`Leaf`和`Composize`有共同的接口，这些方法必须也是接口的一部分。而向`Leaf`对象发送组合体操作消息则没有意义，也不起作用，只有默认的实现\n\n##### 使用场景\n\n1. 想获得对象抽象的树形表示(部分-整体层次结构)\n2. 想让客户端统一处理组合结构中的所有对象\n\n\n\n#### 7. 宏定义、工具类\n\n> 一般项目开发中，我们会频繁的使用某些功能。比如：颜色、字体、设备型号、日志系统、图片拉伸、正则表达式、文件系统、数据库访问......等功能。可以把这些通用的功能封装成函数，或者宏定义方式访问。方便了以后的维护和扩展。\n\n在`AppMacro.h`，定义了设备型号和系统版本号。代码如下：\n\n```\n#define is_iPhone5 ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(640, 1136), [[UIScreen mainScreen] currentMode].size) : NO)\n#define is_iPhone6 ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(750, 1334), [[UIScreen mainScreen] currentMode].size) : NO)\n#define is_iPhone6Plus ([UIScreen instancesRespondToSelector:@selector(currentMode)] ? CGSizeEqualToSize(CGSizeMake(1242, 2208), [[UIScreen mainScreen] currentMode].size) : NO)\n\n#define IOS6_OR_LATER ([[[UIDevice currentDevice] systemVersion] floatValue] >=6.0?YES:NO)\n#define IOS7_OR_LATER ([[[UIDevice currentDevice] systemVersion] floatValue] >=7.0?YES:NO)\n#define IOS8_OR_LATER ([[[UIDevice currentDevice] systemVersion] floatValue] >=8.0?YES:NO)\n```\n\n在`BlockMacro.h`中定义了通用的block。代码如下：\n\n```\ntypedef void(^BlockHttpData)(id respose, NSError *error);\ntypedef void(^BlockJsonData)(id data);\ntypedef void(^BlockCompletion)(BOOL flag, NSError *error);\n\ntypedef void(^BlockTableSection)(NSInteger section, NSInteger row);\n\ntypedef void(^BlockItem)(NSInteger index);\ntypedef void(^BlockResult) (BOOL flag);\n```\n\n在`UIMacro.h`中定义了样式相关的宏定义。代码如下：\n\n```\n///设备宽高\n#define DEVICE_HEIGHT   ([[UIScreen mainScreen]bounds].size.height)\n#define DEVICE_WIDTH    ([[UIScreen mainScreen]bounds].size.width)\n\n#define TAB_HEIGHT 49\n#define NAV_HEIGHT 44\n#define STATUS_HEIGHT 20\n\n// 常用字体\n#define FONT(fontsize)                [UIFont systemFontOfSize:fontsize]\n#define FONT_BOLD(fontsize)           [UIFont boldSystemFontOfSize:fontsize]\n\n// 粗体\n#define FONT_H(fontsize)              [UIFont fontWithName:@\"Helvetica\" size:fontsize]\n#define FONT_H_B(fontsize)            [UIFont fontWithName:@\"Helvetica-Bold\" size:fontsize]\n\n// 字体大小\n#define FONT_TEXT_BIG               FONT_H(19)        // A\n#define FONT_TEXT_NORMAL            FONT_H(17)        // B\n#define FONT_TEXT_SMALL             FONT_H(15)        // C\n#define FONT_TEXT_SMALL2            FONT_H(13)        // D\n#define FONT_TEXT_SMALL3            FONT_H(11)        // E\n#define FONT_TEXT_SMALL4            FONT_H(9)         // F\n\n// App 配置\n#define Color_Nav                   RGB(0,123,252)\n#define Color_Tab                   RGB(240,240,240)\n#define Color_AppBackground         RGB(235, 236, 237)\n\n#define Color_Alert_BackgroundLayer [UIColor colorWithWhite:.5f alpha:0.5f]\n\n#define RGB(Red,Green,Blue)         [UIColor colorWithRed:Red/255.0 green:Green/255.0 blue:Blue/255.0 alpha:1.0]\n#define RGBA(Red,Green,Blue,Alpha)  [UIColor colorWithRed:Red/255.0 green:Green/255.0 blue:Blue/255.0 alpha:Alpha]\n```\n\n在`UtilsMacro.h`中定义了一些函数相关的宏定义：\n\n```\n#define SharedApp ((AppDelegate*)[[UIApplication sharedApplication] delegate])\n\n#define kHarpyCurrentVersion      [[[NSBundle mainBundle] infoDictionary] objectForKey:@\"CFBundleShortVersionString\"]\n\n// block self\n#define WEAKSELF typeof(self) __weak weakSelf = self;\n#define STRONGSELF typeof(weakSelf) __strong strongSelf = weakSelf;\n\n// 图片拉伸\n#define IM_STRETCH_IMAGE(image, edgeInsets) ([image resizableImageWithCapInsets:edgeInsets resizingMode:UIImageResizingModeStretch])\n\n```\n\n你也可以扩展更多功能。\n\n一般的我们需要访问设备文件系统。在`FileManager.h`中接口，定义如下：\n\n```\n///<>/Documents/config.plist\n//程序设置信息\n+ (NSString*)remotePreferenceFile;\n\n///<>/Documents/Crash/crashLog.txt\n// 错误日志\n+ (NSString *)crashFile;\n\n///<>/Library/Caches/mobile.sqlite\n// 用户数据库文件\n+ (NSString *)fmdbFileWithMobile:(NSString *)mobile;\n\n///<><Application_Home>/Documents/app.sqlite\n// App数据库文件\n+ (NSString *)fmdbFile;\n\n///<>/Library/Preferences/Icons\n// 用户头像信息（自己头像，朋友头像）\n+ (NSString *)userImageFileWithMobile:(NSString *)mobile;\n\n///<>/Library/Preferences/<Phonenumber>/user.plist\n//程序设置信息\n+ (NSString*)userPreferenceFile:(NSString*)phoneNumber;\n```\n\n类`NSString+JudgeString`添加了对字符串的正则表达式封装，类`AppPreference`实现了对`NSUserDefault`的二次封装......等。所有的工具类在`Service`模块。"
        },
        {
            "id": "2F79CB00-692F-4C9D-8DE7-1C8CC894977B",
            "categoryId": 1,
            "userID": "9FF36CED-1E38-4149-9B8F-A301BEC52F3B",
            "likeNum": 0,
            "author": "Jerry",
            "isGood": 0,
            "authorImage": "",
            "title": "《解忧杂货店》读后感",
            "viewNum": 5,
            "createTime": 1545723200,
            "collectNum": 0,
            "replyNum": 0,
            "content": "##### 没有停顿一口气一个上午把东野奎吾的《解忧杂货店》看完。每个看似孤立的故事和人生，都因为不同的人生遭遇而曾经交织在一起。故事开始于三个处于下层阶级做了很多小偷小窃的青年人，因为偷来的车坏了而暂时躲在杂货店里，却无缘无故收到别人的求解信，原本自认为没有资格帮别人解忧，但是内心又不安不顾他人的忧虑，于是认真的思考如何解决他人人生的问题。于是接下来一系列事情的发生，甚至他们发现可以和过去的人们通信。\n\n##### 由发现他们可以和过去的人通信开始，故事就多了一些温暖的悬疑，每一封信都高度浓缩了每个普通人的生活，亦是我们常常会碰到的，梦想与责任的选择，人生道路的挣扎，陪酒与正常工作的迷途，男朋友和奥运比赛的矛盾，要不要跟随欠债父母逃亡的犹豫……每一个选择都是那么的严重那么的折磨身心，于是这3个同样在逃亡的人，小心翼翼的给那些40年前的人忠告，小心翼翼的透露一些未来的征兆。同时故事交叉回到40年前浪矢雄治仍活着的时候，他对待每个小孩恶作剧般的问题都饶有兴致绞尽脑汁的回答，甚至后来对每个来信述说烦恼的人感同身受和回复。两个时空的交叉顺气自然，甚至轻而易举的将曾经受过杂货店爷爷亦或这3个逃亡的人帮忙的人现今的状态描述出来。满足我们的好奇心又增加了故事的完整性。\n\n##### 这期间我们都可以感受到，其实每个人都一样，我们都希望对这个社会有用，所以即使那3个逃亡的人仍然会觉得自己有价值是因为解决了别人生活中的困惑，所以即使杂货店已经没有多少人来消费，老人家坚持不关门，可以帮助别人总是好的，也是自己价值的体现！\n\n##### 甚至到后来我们都发现被帮忙的大多数人都来自丸光园孤儿院，然后原来这家孤儿院的创始人曾经是浪矢雄治的爱人，被父母拆散。为了怀念浪矢雄治，他的爱人在离他的家乡不远处开了这家孤儿院，回报社会，同时一辈子没有结婚。这两个不是以圆满为结局的情人，以各自的力量在这个世间促进别人的圆满。\n\n##### 他们都是善良的人，他们都曾被这个社会不公正的对待过，他们都曾在挫折面前看不到前方的路，然后因为解忧杂货店而重拾生活的信心，甚至解忧杂货店其实没有做什么，只是在人们失落的时候给与生活向上的力量。而后靠自己的努力一路照亮生命的道理。然后以感恩的心创造美好的生活。\n"
        },
        {
            "id": "057A4297-2D55-4DCC-8689-E11EFC3C5071",
            "categoryId": 3,
            "userID": "99CAA138-43C1-45D7-9F90-680FB25BCF8D",
            "likeNum": 0,
            "author": "turkeyaa",
            "isGood": 0,
            "authorImage": "8cccd292754f1545724239.6914082.jpg",
            "title": "并发编程",
            "viewNum": 5,
            "createTime": 1545722718,
            "collectNum": 0,
            "replyNum": 0,
            "content": "> 在计算机科学中，并发处理(concurrent processing)是指同时执行多个逻辑控制流(在软件中实现的)。在计算机系统中，并发处理可以在从硬件层到应用层的多个层级中实现。在应用层使用并发处理，可以开发出以并行方式(in parallel)执行多个操作的应用程序，这些操作包括回应异步事件、访问I/O设备、提供网络服务以及进行并行运算等\n\n#### 1.1 并发编程的基本原则\n\n并发编程是一个含有许多概念和创意的广阔领域。因此，在学习这种技术前，了解一些基本术语和各种并发编程的设计概念及优点就非常重要。下面先理解下并发处理与顺序处理的区别。如图：\n\n![并发处理or顺序处理](http://upload-images.jianshu.io/upload_images/1294131-ce5d36e3d57d7842..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n并发处理就意味着同时执行多个任务。但实际上，在设计时希望利用并发机制的程序是否真的会并发执行多任务，取决于运行程序的计算机系统。这就引出了一个必须说明的差异，即并发计算(concurrent computing)和并行计算(parallel computing)的差异。从广义上将，并发计算与设计相关，而并行计算与硬件相关。\n\n> 并行计算 or 并发计算\n\n* 并行计算：指多个软件同时执行多个操作和任务。执行并行计算的能力直接取决于计算机硬件。当今的大多数计算机都拥有多个核心或多个CPU，使得它们能够执行多条指令。\n* 并发计算：指一个软件被设计和实现来同时执行多个操作或任务。如果你的软件是并发编程原则和机制设计并实现的，那么它的某些/所有组件就会根据计算机硬件的能力，以并发方式运行。因此，要发挥并发处理的优势，就必须以相应的方式设计和实现软件，并在能够支持并行处理的硬件上运行它\n\n> 并发编程 or 异步编程\n\n* 并发处理：是指同时处理多个逻辑控制流。\n* 异步处理：是一种对方法和函数进行异步(非阻塞)调用操作的高效机制。换言之，调用了方法后，在该方法被执行时，调用程序仍旧可以继续其处理过程。这种方式抽象化了基础实现机制，可以提高应用程序的响应性、系统的吞吐量等性能指标。可以通过多种设备实现异步处理，也可以通过使用并发编程API和服务来实现。\n\n#### 1.1.1 并发处理的优势\n\n以应用程序级并发处理方式开发程序，可以使程序同时执行多个操作。然而，这些功能并不是没有代价的，要实现这些功能，不仅需要有计算机硬件的支持，而且必须将并行处理思想融入到软件设计和实现过程之中。包括但不限于以下几条：\n\n1. 增加应用程序的吞吐量：因为并发处理会使程序同时处理多个任务，而应用程序的吞吐量就是指在一段时间内应用程序能够完成的任务数，所以并发处理会比顺序处理完成更多任务。\n2. 提高系统利用率：以并行方式执行多个任务，可以更集中、更高效地利用系统资源。\n3. 提供应用程序的整体响应性：以并发方式执行多个任务时，如果某个任务(如输入操作)正在等待，那么其他任务也可以继续运行，婴儿能够减少应用程序的整体闲置时间，提高应用程序的响应性。\n4. 更好地与问题领域契合：在对某些问题(如科学、数学和人工智能领域的)进行建模时，可以将它们创建为同时处理的任务集合。以并发编程方式处理这些模型是更自然、更优的选择。\n\n#### 1.1.2 实现并发处理\n\n在计算机系统中，实现并发处理的方式有很多。下面是几种常见的方式：\n\n1. 分布式计算：在这种并发处理方式中，多个任务会被分给多台通过网络相连的计算机执行，这些计算机通过消息传递来相互通信。\n2. 并行编程：在这种并发处理方式中，通常由多核CPU和可编程GPU进行大量的并行计算。\n3. 多进程：在这种并发处理方式中，多个任务会被分发给一台计算机中的多个进程，每个进程都拥有由操作系统管理的独立资源和地址空间。\n4. 多线程：在这种并发处理方式中，多个任务会与多个线程对应，这些线程会被配置为以并发方式执行。因为这些线程是在单个程序(进程)的环境中被执行的，所以它们会共享资源(如地址空间和内存等)。\n\n#### 1.2 并发处理带来的挑战\n\n正确的使用并发编程并不容易，主要的难点是进行同步操作和在并发执行的控制线程(即逻辑控制流)之间共享信息。在控制不同线程中的相关操作时需要实现同步，而要在线程之间进行通信就必须实现信息共享。\n\n可通过许多机制处理上述难题，其中最常用的两种是共享内存和消息传递。共享内存编程模式会实现共享状态，也就是说，多个线程都可以访问某些程序数据。当程序中的多个线程共同使用某个地址空间时，共享内存就成了信息共享方式的自然自选，既快速又高效。\n\n#### 1.2.1 共享数据\n\n共享内存模式需要一种机制来协调多个线程共用的数据。通常使用同步机制来实现这一目标，例如使用锁或判定条件。**锁** 是一种控制多线程间数据访问和资源共享的机制。线程获得共享资源的锁，对该资源执行操作，接着释放这个锁，然后其他线程才能访问该资源。**条件变量** 是一种同步机制，它使线程一直处于等待状态直到指定条件出现。条件变量通常是使用锁实现的。\n\n#### 1.2.2 锁带来的问题\n\n锁是最常见的控制机制，使用它可以控制多线程对共享数据的访问。锁实施一种互斥策略，从而避免受保护的数据和资源被多个线程同时访问。遗憾的是，在使用锁协调对共享数据的访问时，很可能引发死锁、或锁和资源匮乏问题，这些问题都会导致程序中断。\n\n![死锁](http://upload-images.jianshu.io/upload_images/1294131-fabb6cfe137d5994..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n* 死锁：是指两个或多个线程相互阻塞的情况，每个线程都在等待其他线程释放锁，导致所有线程都一直处于等待状态。死锁的一个例子是循环等待。如上图\n* 活锁：是指一个线程因为要回应其他的一个或多个线程，而导致自身无法继续执行的情况。活锁的线程没有被阻塞，它将所有的计算时间用于回应其他线程，以恢复正常的操作\n* 资源匮乏：是指线程无法访问共享资源的情况，其原因是共享资源被其他线程占用。当一个或多个线程占用共享资源的时间过长时，就会引发这种问题。实际上，可以将活锁视为资源匮乏的一种形式。\n\n下面是一些防止出现这类问题的常用处理方式\n\n* 实现获取锁的总次序：确保进程按照固定次序获取和释放锁。\n* 防止出现保持和等待条件：使线程一次原子获取所有锁。这可以确保在任何时候每个线程都拥有一个锁，从而使程序获得了全局预防锁。这种处理方式消除了出现保持和等待情况的可能性，但可能会降低并发处理的效率，而且需要掌握线程代码的知识。\n* 提供优先权：使用提供试锁(trylock)或类似机制的锁，如果可以，获取锁。如果不行，返回一个合适的结果。这种处理方式会增加出现活锁的可能性，而且需要掌握代码如何使用锁的知识。\n* 设置等待超时：使用提供超时功能的锁，防止出现无限等待的情况。\n\n#### 1.2.3 消息传递\n\n在消息传递模式中，模型状态不是共享的，线程通过交换消息进行通信。这种处理方式使线程能够通过交换消息进行同步和通信。消息传递避免了互斥问题，并自然地与多核、多处理器系统契合。使用消息传递既可以执行同步通信，可以执行异步通信。\n\n在进行同步消息传递时，发送者和接收者会直接连接；消息传递操作完成后，发送者和接收者会断开连接。\n\n异步消息传递通过队列传输消息，而不是在线程之间直接传递。因此，发送者和接收者并不会配对，发送者将消息发送给队列后也无需断开连接。\n\n![queue](http://upload-images.jianshu.io/upload_images/1294131-8960859e77996c48..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 1.3 在 Objective-C 中实现并发编程\n\n* 语言特性：Objective-C语言有多个支持并发编程的特性。使用@synchronized指令可以在Objective-C代码中创建锁。使用atomic属性限定符可以对Objective-C属性进行线程安全的访问\n* 消息传递：Foundation框架中的NSObject类含有多个用于向其他线程发送消息的方法。这些方法会将目标线程运行循环中的消息添加到队列中，而且能够通过通过或异步方式执行。\n* 线程：Foundation框架提供了直接创建和管理线程的整套API。其中还包括用于多线程共享数据进行同步访问的Foundation框架API集。\n* 操作队列：这是基于Objective-C的消息传递机制，它通过异步设计方法实现并发编程\n* 分派队列：这些是基于C语言的一系列语言特性和运行时服务，用于通过异步和并发方式执行任务\n\n#### 1.4 语言特性\n\n@synchronized指令提供了在Objective-C代码中创建锁的简单机制，使并发线程能够同步访问共享状态。\n\n@synchronized指令后面带有一个放在圆括号中的唯一标识符，以及放在花括号中的受保护代码块。这个唯一标识符是一个用于区分受保护代码块的对象。如果有多个线程尝试使用想用的唯一标识符访问这个关键部分，那么这些线程中的某一个线程会先得到锁，而其他线程会被阻塞，直到得到锁的线程完成了对这个关键部分的操作为止。 \n\n```\n// 申明userName属性\n@property (nonatomic, copy) NSString *userName;\n\t\n// 可以这样修改属性值\n@synchronized (_userName) {\n\t// 关键部分 - 被该指令保护的代码\n\t_userName = @\"yuwenhua\";\n}\n```\n\nObjective-C语言还提供了一种用于对属性进行原子访问的特性。原子(atomic)是指不论属性是否被以并发方式访问，属性的访问方法永远都会设置/获取完整(一致性)值。\n\n```\n@property (atomic, copy) NSString *userName;\n```\n\n#### 1.5 消息传递\n\nFoundation框架中的NSObject类含有许多方法，这些方法使用消息传递模式，通过线程调用对象中的方法。可以是主线程或其他线程。\n\n```\n- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay inModes:(NSArray<NSRunLoopMode> *)modes;\n- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;\n......\n```\n\t\nNSObject类中的每个方法都会为接受对象中将被线程调用的方法设置选择器。该方法也叫做线程入口例程。选择器消息会在线程的运行循环中排队，而该方法会作为运行循环中的标准处理过程被线程执行。使用这些消息传递方法，可以设置为同步或异步方式调用线程。同步调用方法会阻塞当前线程，直到该方法执行完为止。因为这些方法是NSObject类定义的，所有NSObject类的所有子类都会拥有这些方法。\n\n> 代码清单 使用NSObject类中的performSelector:onThread: withObject:waitUntilDone: 异步调用线程secondaryThread中的downloadTask方法\n\t\n```\nProcessor *processor = [[Processor alloc] init];\n[processor performSelector:@selector(downloadTask) onThread:secondaryThread withObject:nil waitUntilDone:NO];\n```\n\t\n在创建线程时，可以配置它的部分运行时环境(如栈大小、本地线程存储空间、线程优先权等)。通过使用下列功能实现线程入口点例程：自动释放池、异常处理程序、运行循环。\n\nNSObject类中的performSelectorOnMainThread:方法通常用于，从次要线程对象向主线程对象返回值(如状态、计算结果等)。这样就在次要线程和主线程之间实现了通信。\n\n#### 1.6 线程\n\n线程是指在某个进程环境中执行的逻辑控制流。OS X和iOS操作系统为线程的创建、管理和执行提供了直接的支持。在应用层，Foundation框架提供了许多用于创建和管理线程的API，以及用于在并发线程之间同步共享数据访问的API集合\n\n#### 1.6.1 NSObject线程\n\n使用NSObject类中的performSelectorInBackground:withObject:方法，可以隐式地创建和启动用于执行对象中方法的新线城。该线程会作为后台次要线程立刻启动，而当前进程会立刻返回。这个方法提供了一种使用新后台线程执行对象中方法的简单机制。该线程实例是隐式创建的，因此无需直接使用API。应根据需要，通过自动释放此、异步处理器和运行时循环在方法中配置该线程的环境\n\n```\nProcessor *processor = [[Processor alloc] init];\n[processor performSelectorInBackground:@selector(downloadTask) withObject:nil];\n```\t\n\t\n#### 1.6.2 NSThread\n\nNSThread类提供了用于通过显式创建和管理线程的API。该类含有多个方法，使用这些方法可以创建和初始化NSThread对象、启动和停止线程、配置线程和查询线程及其执行环境\n\n> 下面是NSThread类中用于创建和初始化线程的API：\n\t\n```\ndetachNewThreadSelector:toTarget:withObject:\n\tintiWithTarget:selector:object:\n```\n\t\n该方法会创建新线程并调用接收者的入口点例程(即将该方法与它的选择器对应起来)。不同的是 **intiWithTarget:selector:object:** 方法会创建新线程，但不会启动该线程。当已初始化的线程开始执行接收者的入口点例程时，调用NSThread类的 **start** 方法启动该线程\n\n```\nNSThread *newThread = [[NSThread alloc] initWithTarget:self selector:@selector(downloadTask) object:nil];\n[newThread setThreadPriority:0.5];\n[newThread start];\n\t\n// 线程暂停5秒\n[NSThread sleepForTimeInterval:5.0];\n\t\n```\n\n#### 1.6.3 线程同步\n\nObjective-C平台提供了多种机制来管理共享状态是实现线程之间的同步。Foundation框架中含有一系列锁和条件变量API。\n\n#### 1. 锁\n\nFoundation框架中含有多个类(NSLock、NSRecursiveLock、NSConditionLock、NSDistributedLock)，使用这些类可以实现各种用于同步访问共享状态操作的锁。锁用于保护关键部分(即用于访问共享数据或资源的代码部分)，这些代码不允许多个线程以并发方式执行。\n\nNSLock类为并发编程实现了一种基本的互斥锁。它遵守NSLocking协议，并因此会实现分别用于获取和释放锁的 **lock** 和 **unlock** 方法。前面介绍过@synchronized，它是一种Objective-C语言特性，可以实现媲美NSLock类的互斥锁。主要区别：\n\n1. @synchronized指令隐式创建锁，而NSLock类的API直接创建锁\n2. @synchronized指令会隐式地为关键部分提供异常处理程序，而NSLock类没有提供这一功能\n\n> 代码清单 使用NSLock实例保护关键部分\n\t\n```\nNSLock *computeLock = [NSLock new];\n...\n[computeLock lock];\n\t\n// 关键部分\n...\n\t\n[computeLock unlock];\n```\n\t\nNSDistributedLock类定义了一个可由多台主机上的多个应用程序使用的锁，使用该锁可以控制对共享资源的访问操作。与NSLock类不同，NSDistributedLock实例没有实施互斥策略，而是在锁处于繁忙状态时发送报告，由使用锁的代码根据锁的状态适当地执行操作。下面的代码用一个文件的路径 /hello.lck 创建了分布锁，你可能会将该文件作为锁定系统对象。\n\n> 代码清单 使用NSDistributedLock实例控制对资源的访问\n\t\n```\nNSDistributedLock *fileLock = [NSDistributedLock lockWithPath:@\"/hello.lck\"];\n\t\n// 访问资源\n...\n// 解除对资源的锁定\n[fileLock unlock];\n```\t\n\t\nNSDistributedLock类没有遵守NSLocking协议。而且，因为这个锁是使用文件系统实现的，所以它必须显示释放。如果某个应用程序在拥有分布锁的情况下终止运行，那么其他客户端必须使用NSDistributedLock类中的 **breakLock** 方法才能解除这种锁定\n\nNSConditionLock类定义了一种只有在特定条件下才能获取和释放的锁，这个条件是由你定义的整数值。条件锁通常用于确保任务以指定的顺序执行，如线程之间的厂商-消费者处理流。\n\n> 代码清单 使用NSConditionLock实例控制对资源的访问\n\t\n```\nNSConditionLock *dataLock = [[NSConditionLock alloc] initWithCondition:NO];\n\t\n...\n// 获取锁(缓冲区中没有数据)\n[dataLock lock];\n// 将数据添加到缓冲区中\n\t\n...\n// 根据条件解锁(数据位于缓冲区中)\n[dataLock unlockWithCondition:YES];\n```\n\t\nNSRecursiveLock类定义了一种在不引起死锁的情况下，可以被同一个线程获取多次的锁。\n\n#### 2. 条件\n\n条件变量是一种锁，用于同步操作的执行顺序。尝试获取条件的线程会一直阻塞，直到另一个线程显式地向该条件发出信号(signla)为之。等待某个条件的线程也会一直阻塞，直到另一个线程显式的向该条件发出信号为之。Foundation框架中NSCondition类实现了一种条件变量。\n\n> 使用NSCondition实例同步对共享数据的消费者操作\n\t\n```\n@autoreleasepool {\n        \n\t// 获取条件锁并测试布尔条件\n\t[condition lock];\n\twhile (!self.dataAvailable) {\n\t\t[condition wait];\n\t}\n        \n\t// 数据处于可访问状态后，对数据进行处理(代码已省略)\n\t...\n        \n\t// 完成处理数据的操作，更新判断值和发送信号的条件\n\tself.dataAvailable = NO;\n\t[condition signal];\n        \n\t// 解除条件锁\n\t[condition unlock];\n}\n\n```\n\n#### 1.6.4 使用线程实现并发处理\n\n下面使用线程和这些同步机制创建一个执行并发处理的示例程序。\n\n> 代码清单 ConcurrentProcessor.h\n\t\n```\n@interface ConcurrentProcessor : NSObject\n\n@property (readwrite) BOOL isFinished;\n@property (readonly) NSInteger computeResult;\n\n- (void)computeTask:(id)data;\n\n@end\n\t\n```\n\t\n> 代码清单 \tConcurrentProcessor.m\n\t\n\t@interface ConcurrentProcessor ()\n\n\t@property (readwrite) NSInteger computeResult;\n\n\t@end\n\n\t@implementation ConcurrentProcessor\n\n\t{\n\t\tNSString *computeID;    // @synchronize 指令锁定的唯一对象\n\t\tNSUInteger computeTask; // 并行计算任务的计数\n\t\tNSLock *computeLock;    // 锁对象\n\t}\n\n\t- (id)init {\n\t\tif (self = [super init]) {\n\t\t\t_isFinished = NO;\n\t\t\t_computeResult = 0;\n\t\t\tcomputeLock = [NSLock new];\n\t\t\tcomputeID = @\"1\";\n\t\t\tcomputeTask = 0;\n\t\t}\n\t\treturn self;\n\t}\n\n\t- (void)computeTask:(id)data {\n\t\tNSAssert(([data isKindOfClass:[NSNumber class]]), @\"Not an NSNumber instance\");\n\t\tNSInteger computations = [data integerValue];\n\t\t@autoreleasepool {\n\t\t\t@try {\n\t\t\t\t// 获取所并增加活动任务的计数\n\t\t\t\tif ([[NSThread currentThread] isCancelled]) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t@synchronized (computeID) {\n\t\t\t\t\tcomputeTask++;\n\t\t\t\t}\n            \n\t\t\t\t// 获取所并执行关键代码部分中的计算操作\n\t\t\t\t[computeLock lock];\n\t\t\t\tif ([[NSThread currentThread] isCancelled]) {\n\t\t\t\t\t[computeLock unlock];\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tNSLog(@\"Performing computations\");\n\t\t\t\tfor (NSInteger ii=0; ii<computations; ii++) {\n\t\t\t\t\tself.computeResult++;\n\t\t\t\t}\n\t\t\t\t[computeLock unlock];\n            \t\n\t\t\t\t[NSThread sleepForTimeInterval:1.0];\n            \n\t\t\t\t// 减少活动任务数，如果数量为0，则更新标志位\n\t\t\t\t@synchronized (computeID) {\n\t\t\t\t\tcomputeTask--;\n\t\t\t\t\tif (!computeTask) {\n\t\t\t\t\t\tself.isFinished = YES;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} @catch (NSException *exception) {\n            \n\t\t\t} @finally {\n            \n\t\t\t}\n\t\t}\n\t}\n\n\t@end\n\t\n> 代码清单，客户端代码，在viewDidLoad中添加下面代码\n\t\n\tConcurrentProcessor *processor = [[ConcurrentProcessor alloc] init];\n    \n\t[processor performSelectorInBackground:@selector(computeTask:) withObject:[NSNumber numberWithInteger:5]];\n\n\t[processor performSelectorInBackground:@selector(computeTask:) withObject:[NSNumber numberWithInteger:10]];\n\n\t[processor performSelectorInBackground:@selector(computeTask:) withObject:[NSNumber numberWithInteger:20]];\n\n\twhile (!processor.isFinished);\n    \n\tNSLog(@\"Computation result5 = %d\",processor.computeResult);\n\n> 客户端输出\n\n![线程同步](http://upload-images.jianshu.io/upload_images/1294131-470b5c7b64313ad2..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n#### 1.7 操作和操作队列\n\n#### 1.7.1 操作\n\nNSOperation、NSBlockOperation和NSInvocationOperation类用于管理一个或多个操作、代码以及单个任务关联数据的并行执行过程。操作队列是指提供并行执行任务功能的Objective-C对象。每个任务(即操作)都定义了需要执行的程序和与之相关的数据，而且会被封装在块对象或NSOperation类的具体子类中。NSOperation是一个抽象类，用于封装单个任务和代码和相关数据。在处理并行任务时，具体子类通常只需重写主要方法。至少必须重写 **start** 、**inConcurrent** 、 **isExecuting** 和 **isFinished** 方法。\n\n> 下面的语句创建了一个名为greetingOp的NSBlockOperation实例\n\t\n\tNSBlockOperation *greetingOp = [NSBlockOperation blockOperationWithBlock:^{\n        \n        NSLog(@\"Hello, World!\");\n    }];\n    \n> 还可以使用addExecutionBlock:方法，为NSBlockOperation实例添加额外的块兑现\n\t\n\t[greetingOp addExecutionBlock:^{\n        NSLog(@\"Goodbye\");\n    }];\n    \n\n> 可以使用NSInvocationOperation类初始化实例。然后调用选择器 **hello:** ，并带有NSNumber参数值：\n\t\n\tNSInvocationOperation *invokeOp = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(hello:) object:@(20)];\n\t\n还可以实现自定义操作类。自定义操作类是NSOperation类的子类，至少必须实现用于执行任务的main方法。自定义操作还可以提供下列功能：\n\n* 自定义的初始化方法\n* 自定义的辅助方法(通过main方法调用)\n* 用于设置数据值和访问操作结果的访问器方法\n* 使自定义操作类遵守NSCoding协议的方法(以支持归档对象的功能)\n\n操作对象可以支持各种并发编程功能：\n\n* 在操作对象之间建立依赖关系，从而控制它们的执行顺序\n* 创建在操作的主任务完成后执行的完成语句块\n* 获取操作的执行状态\n* 为操作队列中的操作设置优先权\n* 取消操作\n\n操作对象是通过调用其 **start** 方法执行的。该方法的默认实现会同步执行操作的任务。要实现并发编程的话，可以把操作对象添加到操作队列中执行。\n\n#### 1.7.2 操作队列\n\n操作队列是一种提供并发执行操作能力的机制。Foundation框架中的NSOperationQueue类就是操作队列的一个Objective-C实现。可以将操作作为快对象或NSOperation类的某个子类的实例，添加到NSOperationQueue实例中。操作队列管理操作的执行情况。因此，NSOperationQueue类含有多个方法，使用这些方法可以管理操作队列中的操作、管理正在运行的操作的数量、暂停操作和检索特定的操作队列。\n\n> 向操作队列中添加一个块对象和一个操作\n\t\n\tNSOperationQueue *queue = [[NSOperationQueue alloc] init];\n\t\n\t// 一个块对象\n\t[queue addOperationWithBlock:^{\n        for (NSInteger nn=0; nn<1000; nn++) {\n            NSLog(@\"NN = %d ---- %@\",nn,[NSThread currentThread]);\n        }\n    }];\n    \n    // 一个操作\n    NSBlockOperation *greetingOp = [NSBlockOperation blockOperationWithBlock:^{\n        \n        NSLog(@\"Hello, World!\");\n    }];\n    [queue addOperation:greetingOp];\n    \n将操作添加到队列中后，它会呆在队列中，直到被显式取消或执行完成它的任务为之。通过调用NSOperation对象的 **cancel** 方法或者操作队列中的 **cancelAllOperations** 方法，可以取消操作队列中的NSOperation对象\n\n操作队列中操作的执行顺序取决于操作的优先级和操作对象之间的依赖关系。操作队列中的每个操作都是由独立线程执行的。\n\n#### 1.7.3 实现并发操作 --- 自定义NSOperation子类来实现\n\n> 代码清单，GreetingOperation类继承自NSOperation类，GreetingOperation.m\n\n```\n\n@implementation GreetingOperation\n\n{\n    BOOL finished;\n    BOOL executing;\n}\n\n- (id)init {\n    if (self = [super init]) {\n        executing = NO;\n        finished = NO;\n    }\n    return self;\n}\n\n- (void)start {\n    // 如果操作被取消了就返回结果\n    if ([self isCancelled]) {\n        [self willChangeValueForKey:@\"isFinished\"];\n        finished = YES;\n        [self didChangeValueForKey:@\"isFinished\"];\n        return;\n    }\n    \n    // 使用独立线程执行main方法中的操作\n    [self willChangeValueForKey:@\"isExecuting\"];\n    [NSThread detachNewThreadSelector:@selector(main) toTarget:self withObject:nil];\n    executing = YES;\n    [self didChangeValueForKey:@\"isExecuting\"];\n}\n\n- (void)main {\n    @autoreleasepool {\n        @try {\n            if (![self isCancelled]) {\n                NSLog(@\"Current Thread = %@\",[NSThread currentThread]);\n                NSLog(@\"Hello, World!\");\n                [NSThread sleepForTimeInterval:3.0];\n                NSLog(@\"Goodbye, World!\");\n                \n                [self willChangeValueForKey:@\"isFinished\"];\n                [self willChangeValueForKey:@\"isExecuting\"];\n                executing = NO;\n                finished = YES;\n                [self didChangeValueForKey:@\"isFinished\"];\n                [self didChangeValueForKey:@\"isExecuting\"];\n            }\n        } @catch (NSException *exception) {\n            \n        } @finally {\n            \n        }\n    }\n}\n\n- (BOOL)isConcurrent {\n    return YES;\n}\n\n- (BOOL)isExecuting {\n    return executing;\n}\n\n- (BOOL)isFinished {\n    return finished;\n}\n\n\n@end\n\n```\n\n> 客户端代码\n\t\n\tConcurrentOperation *op = [[ConcurrentOperation alloc] init];\n\t[op start];\n\n#### 1.7.4 实现并发操作 --- 使用操作队列实现并发处理\n\n> 同上，修改客户端代码\n\t\n\tConcurrentOperation *op = [[ConcurrentOperation alloc] init];\n\tNSOperationQueue *queue = [[NSOperationQueue alloc] init];\n\t[queue addOperation:op];\n\t[queue waitUntilAllOperationsAreFinished];\n\n#### 1.8 分派队列\n\nGrand Central Dispatch(GCD)是一个集合，它含有语言特性、基于C语言的API、以及支持使用分派队列执行任务的系统增强功能。使用GCD分派队列可以同步或异步地执行代码，以及串行或并行的执行任务。与操作队列一样，分派队列也比线程更易于使用，执行异步或并发任务更高效。\n\n> 客户端代码，在viewDidLoad中添加\n\t\n\t// 创建顺序队列和分组\n\tdispatch_queue_t serialQueue = dispatch_queue_create(\"com.ds.turkey\", DISPATCH_QUEUE_SERIAL);\n    \n\tdispatch_group_t group = dispatch_group_create();\n    \n\t// 向队列中添加任务\n\tdispatch_group_async(group, serialQueue, ^{\n\t\tNSLog(@\"First task\");\n\t\t[NSThread sleepForTimeInterval:2];\n\t\tNSLog(@\"First task over\");\n\t});\n\tdispatch_group_async(group, serialQueue, ^{\n\t\tNSLog(@\"Second task\");\n\t\t[NSThread sleepForTimeInterval:2];\n\t\tNSLog(@\"Second task over\");\n\t});\n    \n\t// 等待，当分组中的所有任务都完成时\n\t// 作其他处理\n\tdispatch_group_notify(group, serialQueue, ^{\n\t\tNSLog(@\"所有任务都已经完成\");\n\t});\n\tNSLog(@\"Over\");\n\t\n\t// 结果为：\n\t2017-05-27 09:25:35.372 Test_concurrent[3126:74272] Over\n\t2017-05-27 09:25:35.372 Test_concurrent[3126:74358] First task\n\t2017-05-27 09:25:37.375 Test_concurrent[3126:74358] First task over\n\t2017-05-27 09:25:37.376 Test_concurrent[3126:74358] Second task\n\t2017-05-27 09:25:39.377 Test_concurrent[3126:74358] Second task over\n\t2017-05-27 09:25:39.378 Test_concurrent[3126:74358] 所有任务都已经完成\n\t\n这段代码使用GCD API创建并以异步方式分派了3个串行执行的任务，从而协调了它们的执行次序，防止了它们对共享数据进行并发访问。最后 **dispatch_group_async** 函数监听任务是否完成，可以作出对结果的处理(更新界面)。"
        },
        {
            "id": "27B80977-C9C8-4DFA-9B7B-B259801C067C",
            "categoryId": 3,
            "userID": "99CAA138-43C1-45D7-9F90-680FB25BCF8D",
            "likeNum": 1,
            "author": "turkeyaa",
            "isGood": 0,
            "authorImage": "8cccd292754f1545724239.6914082.jpg",
            "title": "运行时系统",
            "viewNum": 10,
            "createTime": 1545722685,
            "collectNum": 0,
            "replyNum": 0,
            "content": "> Objective-C 拥有相当多的动态特性，这些特性在运行程序时发挥作用，而不是在编译或者链接代码时发挥作用。Objective-C运行时系统实现了这些特性，而这些功能为Objective-C语言提供了非常多的强大功能和灵活性。\n\n* 运行时系统\n* 运行时系统的结构\n* 使用运行时系统API\n\n***\n\n### 运行时系统\n\n#### 1.1 动态功能\n\n在运行时，Objective-C语言会执行其他语言在程序编译或链接时会执行的许多常规操作，如确定类型和方法解析。这些操作还可以提供API，使你编写的程序能够执额外的运行时操作，如对象内省和以动态方式创建和加载代码。Objective-C运行时系统的结构和实现方式生成了这些动态特性\n\n#### 1.2 对象消息\n\n在OOP术语中，消息传递是指一种在对象之间发送和接受消息的通信模式。用于调用类和类实例的方法。\n\n对象消息传递是以动态方式实现的特性，接收器的类型和相应的调用方法是在运行时决定的。\n\n* 消息：向对象/类发送的名称(选择器)和一些列参数\n* 方法：Objective-C中的类或实例方法，其申明中含有名称、输入参数、返回值和方法签名(即输入参数和返回值的数据类型)\n* 方法绑定：接收向指定接收器发送的消息并寻找和执行适当方法的处理过程。Objective-C运行时系统在调用方法时，会以动态绑定方式处理消息。\n\n#### 1.3 选择器\n\n选择器是一种文本字符串，用于指明调用对象或类中的哪些方法。选择器是一种分为多个段的文本字符串，每个段以冒号结尾并且后跟参数，例如：\n\n```\n分段1：分段2：分段3：\n```\n\t\n这个选择器中有3个分段，每个分段都带一个冒号，因而表明了相应的消息具有3个输入参数。\n\n```\n// 选择器示例\ndescription\ndescription:\nsumAddend1:addend2:\nsumAddend1::\n```\n\n消息的选择器直接与一个或多个类/实例方法声明对应。下面展示一个类接口，该接口中含有一个实例方法声明\n\n```\n@interface Calculator : NSObject\n- (int)sumAddend1:(NSInteger)a1 addend2:(NSInteger)a2;\n@end\n```\n  \t\nCalculator 类实例方法的选择器为sumAddend1:addend2:。如果初始化一个Calculator对象并将其分配给一个名为myCalculator的变量，那么调用该实例方法就需要使用接收器对象(myCalculator)后跟带输入参数的选择器，例如：\n\n```\n[myCalculator sumAddend1:25 addend2:10];\n```\n\t\n当源代码被编译时，编译器(运行时系统的组成部分)会创建数据结构和函数调用语句，使用它们以动态方式将接收器(类/对象)和消息选择器与方法的实现代码对应起来。在执行程序时，运行时库(运行时系统的另一个组成部分)利用这些消息找到并调用适当的方法。\n\n选择器类型(SEL)是一种特殊的Objective-C数据类型，是用于在编译源代码时替换选择器值的唯一标识符。所有具有相同选择器值的方法都拥有相同的SEL标识符。可使用关键字@selector创建SEL类型的变量，例如：\n\n```\nSEL myMethod = @selector(myMethod:);\n```\n\t\n如果在运行时创建选择器变量，可以这样写：\n\n```\nSEL myMethod = NSSelectorFromString(@\"myMethod:\");\n[obj performSelector: myMethod withObject:[NSNumber numberWithInteger:40]];\n```\n\t\n#### 1.4 方法签名\n\n方法签名(method signature)定义了方法输入参数的数据类型和方法的返回值(如果存在)。编译器会将 [接收器 消息] 形式的对象消息，转换为声明中含有方法签名的(ANSI)C函数调用语句。因此，为了生成正确的对象消息传递代码，编译器需要获得选择器值和方法签名。编译器可以从对象消息表达式中轻松提取选择器，但是它如何获取方法签名呢?消息可能含有输入参数，而且因为接收器和相应的方法是在程序运行时确定的，所以编译器无法知道使用怎样的数据类型才能与要调用的方法对应起来。为了确定正确的方法签名，编译器会根据已解析的方法声明进行猜测。如果它找不到方法签名，或者它从方法声明获得的方法签名与运行时实际执行的方法不匹配，就会出现方法签名不匹配的情况，会导致从编译器警告道运行时错误的各种问题。\n\n#### 1.5 使用对象消息\n\n创建Calculator类，继承NSObject类，添加两个实例方法：sumAddend1:addend2: 和 sumAddend1::。\n\n```\n@interface Calculator : NSObject\n\n- (NSNumber *)sumAddend1:(NSNumber *)a1 addend2:(NSNumber *)a2;\n- (NSNumber *)sumAddend1:(NSNumber *)a1 :(NSNumber *)a2;\n\n@end\n```\n\n我们可以这样调用该方法\n\n```\nCalculator *obj = [[Calculator alloc] init];\nNSNumber *rs1 = [obj sumAddend1:@(10) addend2:@(15)];\nNSNumber *rs2 = [obj sumAddend1:@(10) :@(25)];\n```\n\t\n或者通过运行时方式调用该方法\n\n```\nSEL myMethod = NSSelectorFromString(@\"sumAddend1::\");\nNSNumber *rs3 = [obj performSelector:myMethod withObject:@(10) withObject:@(35)];\n```\n\t\n#### 1.5 动态类型\n\n运行时系统通过动态类型(dynamic typing)功能，可以在运行程序时决定对象的类型，因而可以使运行时因素能够在程序中指定使用哪种类型对象。在事先无法知道为变量分配那种类型的对象的情况下(如向方法传送参数)，这就特别有用。既支持静态类型也支持动态类型。当使用静态方式设置变量的类型时，变量的类型就由它的声明决定。\n\n```\n// 变量 myAtom 声明为指向Atom类实例的指针\nAtom *myAtom;\n\t\n// myAtom 声明为id数据类型，运行时检查myAtom类型\nid *myAtom;\n```\n\t\n使用动态类型可以简化类接口，无须为每个可能出现的输入参数类型编写不同的方法声明。动态类型还可以提供非常大的灵活性，可以在执行程序的过程中改进程序使用的数据类型，并在不重新编译和重新部署的情况下引入新的数据类型。\n\n#### 1.6 动态绑定\n\n动态绑定是指在运行时(而不是编译时)将消息与方法对应起来的处理过程。因为许多接收器对象会实现相同的方法，调用方法的方式会动态变化。因此动态绑定实现了 OOP 的多态性。使用动态绑定可以在不影响既有代码的情况下，将新对象和代码连接或添加到系统中，从而降低对象之间的耦合度。通过消除用于处理多选情景(通常由条件语句实现)的条件逻辑，动态绑定还能够降低程序的复杂度。如图：\n\n![动态绑定](http://upload-images.jianshu.io/upload_images/1294131-46bf2da1aef12213..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n```\nid atom = [[Hydrogen alloc] initWithNeutrons:1];\n[atom logInfo];\n```\n\t\n在执行这段代码时，运行时系统会确定变量atom的实际类型(通过动态绑定)，然后使用消息选择器(logInfo)将该消息与接收器(atom对象)的实例方法对应起来。在本例中，变量atom的类型被设置为Hydrogen *，因此运行时系统会搜索Hydrogen类中的实例方法logInfo。如果找不到，那么它就会在Hydrogen类的父类中寻找相应的实例方法。运行时系统会一直在类层次结构中寻找该实例方法，直到找到为止。否则方法被转发甚至异常。\n\n#### 1.7 动态方法决议\n\n使用动态方法决议能够以动态方式实现方法。使用Objective-C中的@dynamic指令，可以告知编译器与属性关联的方法会议动态方式实现。NSObject类中含有 ``` resolveInstanceMethod: ``` 和 ``` resolveClassMethod: ``` 方法，它们能够以动态方式分别为指定的实例和类方法选择器提供实现代码。你可以重写这些方法，以动态方式实现实例/类方法。下面例子：\n\n```\n#import <objc/runtime.h>\n+ (BOOL)resolveInstanceMethod:(SEL)sel {\n\tNSString *method = NSStringFromSelector(sel);\n\tNSLog(@\"Selector name = %@\",method);\n\tif ([method hasPrefix:@\"absoluteValue\"]) {\n\t\tclass_addMethod([self class], sel, (IMP)absoluteValue, \"@@:@\");\n\t\tNSLog(@\"Dynamically instance method %@ to class %@\",method,[self class]);\n\t\treturn YES;\n\t}\n\treturn [super resolveInstanceMethod:sel];\n}\n\t\n// 添加该方法\nid absoluteValue(id self, SEL _cmd, id value) {\n\tNSInteger intValue = [value integerValue];\n\tNSLog(@\"Self = %@, value = %@\",self,value);\n\tif (intValue < 0) {\n\t\treturn [NSNumber numberWithInteger:(intValue * -1)];\n\t}\n\telse {\n\t\treturn [NSNumber numberWithInteger:intValue+1];\n\t}\n}\n\t\n// 客户端调用\nCalculator *obj = [[Calculator alloc] init];\n    \nSEL selector = NSSelectorFromString(@\"absoluteValue:\");\nid sum = [obj performSelector:selector withObject:[NSNumber numberWithInteger:40]];\nNSLog(@\"sum = %@\",sum);\n    \n// 结果 sum = 41\n```    \n    \n这段代码以动态方式为新建方法创建了一个选择器，然后使用该选择器调用了一个实例方法。通过动态方法决议可以在运行时添加和调用这个方法，并获得返回值。\n\n#### 1.8 内省\n\nFoundation框架中NSObject类的API含有非常多用于执行对象内省的方法。因为Objective-C的运行时行为与它的编译和链接时行为差异非常大，所以对象内省就成为了一种关键功能，使用它可以避免运行时错误。使用这些方法能够以动态方式在程序运行时查询下列信息：\n\n* 与方法有关的信息；\n* 测试对象的继承性、行为和一致性的信息。\n\n测试接收器是Calculator类的实例还是Calculator类的子类的实例\n\n```\nBOOL isCalculator = [obj isKindOfClass:[Calculator class]];\n```\n\t\n检查某个对象是否会对选择器做出回应\n\n```\nBOOL responds = [obj respondsToSelector:@selector(sumAddend1::)];\n```\n\t\n检查对象是否遵守指定协议\n```\nBOOL conforms = [obj conformsToProtocol:@protocol(MyProtocol)];\n```\n\t\n为选择器提取方法签名\n```\nNSMethodSignature *signature = [obj methodSignatureForSelector:@selector(sumAddend1::)];\n```\n\n***\n\n### 运行时系统的结构\n\n> Objective-C的运行时系统由两个主要部分构成：编译器和运行时系统库。\n\n#### 2.1 编译器\n\n编译器会接收Objective-C源文件并进行处理(该处理过程由词法分析、语法分析、代码生成和优化、汇编以及链接操作等阶段构成)，生成构成可执行程序的二进制文件。编译器的作用是接收输入的源代码，生成使用了运行时系统库的代码，从而得到合法的、可执行的Objective-C程序。\n\n#### 2.2 运行时系统库\n\n就像C语言标准函数库会为C语言程序提供标准API和实现代码一样，运行时系统库也会为Objective-C的面向对象特性提供标准API和实现代码。这种库与所有Objective-C程序链接。\n\n运行时系统由下列部分组成：\n1. 类元素(接口、实现代码、协议、分类、属性、实例变量)\n2. 类实例(对象)\n3. 对象消息传递(包括动态类型和动态绑定)\n4. 动态方法决议\n5. 动态加载\n6. 对象内省\n\n运行时系统的公用API是在头文件runtime.h中声明的。可以从 [http://opensource.apple.com](http://opensource.apple.com)获取苹果公司提供的运行时系统库。随着Objective-C语言的不断发展，将它与各种设计元素与系统服务一同使用，可以获得更好的性能和可扩展性。\n\n使用运行时系统库API创建类\n\n```\n#import <objc/runtime.h>\n#import <objc/message.h>\n\t\nNSString *greeting2(id self, SEL _cmd) {\n\treturn [NSString stringWithFormat:@\"Hello, World!\"];\n}\n\t\n// 以动态的方式创建一个类\nClass dynaClass = objc_allocateClassPair([NSObject class], \"DynaClass\", 0);\n// 以动态方法添加一个方法，使用已有的方法 (description)获取特性\nMethod description = class_getInstanceMethod([NSObject class], @selector(description));\nconst char *type = method_getTypeEncoding(description);\nclass_addMethod(dynaClass, @selector(greeting2), (IMP)greeting2, type);\n    \n// 注册这个类\nobjc_registerClassPair(dynaClass);\n    \n// 使用该类创建一个实例并向其发送一条消息\nid dynaObj = [[dynaClass alloc] init];\n    \nSEL selector = NSSelectorFromString(@\"greeting2\");\nNSString *rs = [dynaObj performSelector:selector];\nNSLog(@\"rs = %@\",rs);\n\n// 结果为： rs = Hello, World!\n```\n\n首先导入头文件才能将运行时系统库中的消息传递API。它创建了一个类对(类及其元类)，向这个类对中添加了一个指向先前创建的greeting2()函数的方法，然后在运行时注册该类对，从而使你编写的程序能够创建这个类的实例。方法签名是通过使用拥有相同签名的方法(NSObject类的description方法)获取的。再然后创建了一个类实例并向其发送了一条消息，然后将获得的结果显示到输出窗格中。\n\n\t运行时系统库含有可用于访问下列信息的函数(括号中为函数名)\n* 对象的类定义(objc_getClass)\n* 类的父类(class_getSuperClass)\n* 对象的元类定义(objc_getMetaClass)\n* 类的名称(class_getName)\n* 类的版本信息(class_getVersion)\n* 以字节为单位的类尺寸(class_getInstanceSize)\n* 类的实例变量列表(class_copyIvarList)\n* 类的方法列表(class_copyMethodList)\n* 类的协议列表(class_copyProtocolList)\n* 类的属性列表(class_copyPropertyList)\n\n总而言之，运行时系统库数据类型和函数为运行时系统库提供了实现各种Objective-C特性(如对象消息传递)所必需的数据类型和函数。当程序向对象发送消息时，运行时系统会通过自定义代码中的类方法缓存和虚函数表，查找类的实例方法。为了找到相应的方法，运行时系统会搜索整个类层次结构，找到该方法后，它就会执行该方法的实现代码。\n\n![运行时系统中的消息传递操作](http://upload-images.jianshu.io/upload_images/1294131-540f285ce6025e95..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n运行时系统库中的方法数据类型\n\n```\nstruct objc_method\n{\n\tSEL method_name;\n\tchar *method_types;\n\tIMP method_imp;\n};\ntypedef objc_method Method;\n```\n\t\n运行时系统库的方法查询逻辑\n\n![运行时系统库的方法查询逻辑](http://upload-images.jianshu.io/upload_images/1294131-195813f9a2999cdd..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\t\n***\n\n### 使用运行时系统API\n\n#### TODO"
        },
        {
            "id": "49A00A3B-33BB-423C-8CC5-A39B0508CD31",
            "categoryId": 8,
            "userID": "99CAA138-43C1-45D7-9F90-680FB25BCF8D",
            "likeNum": 0,
            "author": "turkeyaa",
            "isGood": 0,
            "authorImage": "8cccd292754f1545724239.6914082.jpg",
            "title": "编码规范",
            "viewNum": 3,
            "createTime": 1545722653,
            "collectNum": 0,
            "replyNum": 0,
            "content": "> 编码规范简单来说就为了保证写出来的代码具备三个原则：可复用、易维护、可扩展. 这其实也是面向对象的基本原则. 可复用, 简单来说就是不要写重复的代码, 有重复的部分要尽量封装起来重用.易维护, 就是不要把代码复杂化, 不要去写巨复杂逻辑的代码, 而是把复杂的逻辑代码拆分开一个个小的模块, 这也是Do one thing的概念, 每个模块(或者函数)职责要单一, 这样的代码会易于维护, 也不容易出错. 可扩展则是要求写代码时要考虑后面的扩展需求, 这个属于架构层面的东东, 利用对应的设计模式来保证，本内容主要讨论第1点。\n\n###### 本章通过命名规范和编码规范来详细讨论\n\n* 命名规范\n* 编码规范\n\n\n### 1. 命名规范\n\n###### 主要涉及常量和变量命名、枚举命名、类及其方法命名，以及分类及其方法命名。\n\n1.1 使用 #define 预处理定义常量。定义一个 ANIMATION_DURATION 常量来表示 UI 动画的一个常量时间，这样代码中所有使用 ANIMATION_DURATION 的地方在编译阶段都会被替换成 0.3。无类型信息，不便于调试。不推荐\n\n```\n#define ANIMATION_DURATION    0.3\n```\n\n1.2 使用类型常量，对于局部常量通常以字符 k 开头，且需要以 static const 修饰。推荐\n\n```\t\nstatic const NSTimeInterval kAnimationDuration = 0.3;\n```\n\n1.3 使用类型常量，外部可见，则通常以定义该常量所在类的类名开头。\n\n\t// 数值常量\n\tEOCViewClass.h\n\textern const NSTimeInterval EOCViewClassAnimationDuration;\n\n\tEOCViewClass.m\n\tconst NSTimeInterval EOCViewClassAnimationDuration = 0.3;\n\n\n\t// 字符串常量\t\n\tEOCViewClass.h\n\textern NSString *const EOCViewClassStringConstant;\n\n\tEOCViewClass.m\n\tNSString *const EOCViewClassStringConstant = @\"EOCStringConstant\";\n\n\n1.4 用枚举表示状态、选项、状态码\n\t\n\t// 通用枚举值\n\ttypedef NS_ENUM(NSInteger, RoomType) {\n    \tRoomType_Normal,     // 虚拟诊室\n\t    RoomType_Exam,       // 考试诊室\n\t    RoomType_Talk,       // 讨论区诊室\n\t    RoomType_XGuang,     // 能力 X 光\n\t};\n\t\n\n1.5 需要以按位或操作来组合枚举的都应使用 NS_OPTIONS 宏来定义。\n\t\n\t// 位移相关操作的枚举值\n\ttypedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) {\n\t    UIViewAutoresizingNone                 = 0,\n    \tUIViewAutoresizingFlexibleLeftMargin   = 1 << 0,\n\t    UIViewAutoresizingFlexibleWidth        = 1 << 1,\n\t    UIViewAutoresizingFlexibleRightMargin  = 1 << 2,\n    \tUIViewAutoresizingFlexibleTopMargin    = 1 << 3,\n\t    UIViewAutoresizingFlexibleHeight       = 1 << 4,\n    \tUIViewAutoresizingFlexibleBottomMargin = 1 << 5\n\t};\n\t\n\t// 然后就可以通过组合的方式来使用\n\tself.tableView.autoresizingMask = UIViewAutoresizingFlexibleWidth | UIViewAutoresizingFlexibleHeight;\n\n\n1.6 变量和对象的命名，给一个对象命名时建议采用 ’修饰+类型‘ 的方式，对于 BOOL 类型，应加上 is/has 前缀。私有实例变量前加一个下划线，如：_myPrivateVarible\n\n\n\t@property (nonatomic, strong) UIButton *closeBtn;    // 表示关闭的button，是 UIButton 类型\n\t@property (nonatomic, strong) UILabel *titleLabel;   // 表示标题的label，是 UILabel 类型\n\t@property (nonatomic, assign) BOOL isShowLeft;       // 表示是否显示Left，是 BOOL 类型\n\n\t- (BOOL)isEqualToString:(NSString *)aString;\n\t- (BOOL)hasPrefix:(NSString *)aString;\n\t\n\t// 这是一个成员变量，添加一个下划线\n\tNSString *_userId;\n\n\n1.7 方法的命名，应该全部使用有意义的单词组成，且以小写字母开头，多单词组合时，后面的单词首字母大写，参数过多时，推荐每个参数各占一行。如果是私有方法建议加上 'private'/'p_' 作为前缀，很容易的将其同公共方法区分开\n\n\t- (id)initWithAccount:(NSString *)account\n            \t password:(NSString *)psw;\n            \t \n    - (id)privateMethod;\n    - (id)p_method;\n             \n\n1.8 类的命名，首字母大写，之后每个单词首字母都大写，使用能够反映类功能的名词短语，使用前缀来避免命名空间冲突，如：ABC+类名(ABCUserInfo)\n\n\t// 这是一个模型\n\t@interface UserModel : JSONModel\n\t// 这是一个视图\n\t@interface BaseNavView : BaseView\n\t// 这是一个视图控制器\n\t@interface LoginVC : BaseVC\n\t// 这是一个接口\n\t@interface Login_Post : BaseRestApi\n\t\n\t// 添加前缀\n\t// 这是一个模型\n\t@interface TLQUserModel : JSONModel\n\t// 这是一个视图\n\t@interface TLQBaseNavView : BaseView\n\t// 这是一个视图控制器\n\t@interface TLQLoginVC : BaseVC\n\t// 这是一个接口，POST 方式\n\t@interface TLQLogin_Post : BaseRestApi\n\t// 这是一个接口，GET 方式\n\t@interface TLQCreatePatient_Get : BaseRestApi\n\n1.9 分类的命名，与类命名相同，此外需添加要扩展的类名和 “+”，如：NSString+JudgeString\n\t\n\t// 与字符串操作相关的分类\n\t// 这是文件名\n\tNSString+JudgeString.h\n\t// 这是类名\n\t@interface NSString (JudgeString)\n\n\n1.10 协议的命名，与类命名相同，需添加 \"Delegate\" 后缀，如：ReplyViewDelegate\n\t\n\t// 协议的命名\n\t@protocol ShaftAdviceViewDelegate;\n\n1.11 图片命名，使用英文，首字母大写，之后每个单词首字母都大写并添加模块作为前缀，避免冲突图片应该与类文件一样，按模块分组放置\n\t\n\t// 这是沙河路径\n\t<Application_Home>/Documents/\n\t<Application_Home>/Library/Preferences/\n\t<Application_Home>/Library/Caches/\n\t<Application_Home>/tmp/\n\t\n\t// 这是用户头像路径\n\t<Application_Home>/Library/Preferences/Icons/(userId).png\n\t\n\t// 这是 app 图片资源, xxx 表示图片唯一名称\n\t<Application_Home>/Library/Caches/Icons/(xxx).png\n\t\n\t// 这是用户信息路劲\n\t<Application_Home>/Library/Preferences/Infos/(userId).plist\n\t\n\t// 这是数据库路劲\n\t<Application_Home>/Documents/app.sqlite\n\t\n### 2. 编码规范\n\n1. 让别人能读懂的代码\n2. 可扩展的代码\n3. 可测试的代码\n\n2.1 判断 nil 或者 YES/NO\n\n\t// Preferred:\n\tif (someObject) { ... } \n\tif (!someObject) { ... }\n\t\n\t// Not preferred:\n\tif (someObject == YES) { ...} \n\tif (someObject != nil) { ...}\n\n\n2.2 条件赋值.\n\n\t// Preferred:\n\tresult = object ? : [self createObject];\n\n\t// Not preferred:\n\tresult = object ? object : [self createObject];\n\n\n2.3 初始化方法，推荐使用字面量方式.\n\n\t// Preferred:\n\tNSArray *names = @[@\"Brian\", @\"Matt\", @\"Chris\", @\"Alex\", @\"Steve\"];\n\tNSDictionary *productManagers = @{@\"iPhone\" : @\"Kate\", @\"iPad\" : @\"Kamal\"};\n\tNSNumber *shouldUseLiterals = @YES;\n\tNSNumber *buildingZIPCode = @10018;\n\t\n\t// Not Preferred:\n\tNSArray *names = [[NSArray alloc] initWithObjects:@\"Brian\",@\"Matt\",@\"Chris\",@\"Alex\",@\"Steve\", nil];\n\tNSDictionary *productManagers = [[NSDictionary alloc] initWithObjectsAndKeys:@\"iPhone\", @\"Kate\", @\"iPad\", @\"Kamal\", nil];\n\tNSNumber *shouldUseLiterals = [NSNumber numberWithBool:YES];\n\tNSNumber *shouldUseLiterals = [NSNumber numberWithInteger:10018];\n\t\n\t\n2.4 BOOL 赋值，使用三目运算符，更简洁.\n\n\t// Preferred:\n\tBOOL isAdult = age > 18;\n\n\t// Not preferred:\n\tBOOL isAdult;\n\tif (age > 18)\n\t{\n    \tisAdult = YES;\n\t}\n\telse\n\t{\n    \tisAdult = NO;\n\t}\n\t\n\t// Preferred:\n\tresult= num1 > num2 ? num1:num2;\n\t\n\t// Not preferred:\n\tif (num1 > num2) \n\t{\n\t\tresult = num1;\n\t}\n\telse\n\t{\n\t\tresult = num2;\n\t}\n\n2.5 拒绝死值，使用变量，即间接的方式，每次修改的时候容易被遗忘，地方多了修改就麻烦了.\n\n\t// Preferred:\n\tif (car == Car.Nissan)\n\t// or\n\tconst int adultAge = 18; if (age > adultAge) { ... }\n\n\t// Not preferred:\n\tif (carName == \"Nissan\")\n\t// or\n\tif (age > 18) { ... }\n\n\n2.6 嵌套判断，一旦发现某个条件不符合，立即返回，条理更清晰.\n\n\n\t// Preferred:\n\tif (!user.UserName) return NO;\n\tif (!user.Password) return NO;\n\tif (!user.Email) return NO;\n\n\treturn YES;\n\n\t// Not preferred:\n\tBOOL isValid = NO;\n\tif (user.UserName)\n\t{\n    \tif (user.Password)\n\t    {\n    \t    if (user.Email) isValid = YES;\n\t    }\n\t}\n\treturn isValid;\n\n\n2.7 参数过多，可以聚合成一个 model 类，代码更简洁.\n\n\t// Preferred:\n\t- (void)registerUser(User *user)\n\t{\n    \t // to do...\n\t}\n\n\t// Not preferred:\n\t- (void)registerUserName:(NSString *)userName\n    \t            password:(NSString *)password \n        \t           email:(NSString *)email\n\t{\n    \t // to do...\n\t}\n\n\n2.8 Block 的循环引用问题，解决方法很简单, 就是在block体内define一个strong的self, 然后执行的时候判断下self是否还在, 如果在就继续执行下面的操作, 否则return或抛出异常.\n\n\t// weakSelf 可能被释放，导致奇怪的错误\n\t__weak typeof(self) weakSelf = self;\n\tdispatch_block_t block =  ^{\n    \t[weakSelf doSomething]; // weakSelf != nil\n\t    // preemption, weakSelf turned nil\n    \t[weakSelf doSomethingElse]; // weakSelf == nil\n\t};\n\n\t\n\t// strongSelf 不会被释放 - 推荐使用\n\t__weak typeof(self) weakSelf = self;\n\tmyObj.myBlock =  ^{\n    \t__strong typeof(self) strongSelf = weakSelf;\n    \tif (strongSelf) {\n\t      [strongSelf doSomething]; // strongSelf != nil\n    \t  // preemption, strongSelf still not nil\n\t      [strongSelf doSomethingElse]; // strongSelf != nil\n\t    }\n    \telse {\n        \t// Probably nothing...\n\t        return;\n    \t}\n\t};\n\n\n2.9 建议：#import 头文件按模块来分,更直观.\n\n\t// Cell\n\t#import \"LogInCell.h\"\n\t#import \"LogOutCell.h\"\n\t// Setting\n\t#import \"AppPreference.h\"\n\t#import \"AppDelegate.h\"\n\t// VC\n\t#import \"LoginVC.h\"\n\t#import \"UserInfoVC.h\"\n\t#import \"SettingVC.h\"\n\t// Notify\n\t#import \"LoginNotify.h\"\n\t// View\n\t#import \"DSTabbar.h\"\n\t#import \"InvitationView.h\"\n\t// Api\n\t#import \"LoginStatus_Get.h\"\n\n2.10 建议：@class与#import，如需要继承类或执行协议,可以在.h中进行#import类或协议;其他情况下,在.h中声明用@classs声明此类即可。这样可以减少因头文件依赖引起重复编译,提高编译速度,也解决了两个类的相互引用问题.\n\n\t// 在 .h 文件中通过 class 关键字来引用\n\t@class PatientInfo;\n\t@interface CreatePatient_Get : BaseRestApi\n\t@property (nonatomic, strong) PatientInfo *patientInfo;\n\t@end\n\t\n\t// 而在 .m 文件中通过 import 关键字来引用\n\t#import \"PatientInfo.h\"\n\t@implementation CreatePatient_Get\n\t@end\n\n2.11 注释，可以采用 “ /**/ ” 和 // 两种注释符号，涉及多行注释时，第一种。对于一行代码的注释可放在前一行或本行上，不允许放在下一行。显而易见的代码不需要加注释.\n\t\n\t// 这里是多行注释\n\t/**\n\t *  登录接口\n\t *\n\t *  @param account 账号\n\t *  @param psw     密码\n\t */\n\t- (id)initWithAccount:(NSString *)account\n    \t         password:(NSString *)psw;\n\n\t\n\t// 这里是单行注释，写在上一行\n\t// 病程ID\n\t@property (nonatomic, strong) NSString *status_id;\n\t\n\t// 这里是单行注释，写在同一行\n\t@property (nonatomic, strong) NSString *status_id; // 病程ID\n\t\n2.12 注册通知时，在视图控制器销毁的时候，需要删除通知.\n\t\n\t// 删除通知\n\t- (void)dealloc {\n    \t[[NSNotificationCenter defaultCenter] removeObserver:self];\n\t    [[LoginNotify sharedInstance] removeLoginObserver:self];\n\t}\n\n2.13 启动了一个定时器，在控制器销毁的时候，需要关闭定时器.\n```\n// 关闭定时器\n- (void)viewWillDisappear:(BOOL)animated {\n    [super viewWillDisappear:animated];\n\tif (_timer) {\n   \t    dispatch_source_cancel(_timer);\n        _timer = nil;\n      }\n}\n```\n2.14 建议：在添加通知的时候，可以把每个通知都包装成独立的方法，就可以复用，而不需要重复的写相同的通知。以功能模块来区分通知的类型。\n\n\t// Preferred:\n\t\n\t// 与登录相关的通知\n\t@interface LoginNotify : NSObject\n\t\n\t+ (instancetype)sharedInstance;\n\t\n\t#pragma mark - login\n\t- (void)addLoginObserver:(id)target selector:(SEL)selector;\n\t- (void)removeLoginObserver:(id)target;\n\t- (void)postLoginNotify;\n\n\t#pragma mark - louout\n\t- (void)addLogoutObserver:(id)target selector:(SEL)selector;\n\t- (void)removeLogoutObserver:(id)target;\n\t- (void)postLogoutNotify;\n\n\t#pragma mark - automatic login\n\t- (void)addAutomaticLoginObserver:(id)target selector:(SEL)selector;\n\t- (void)removeAutomaticLoginObserver:(id)target;\n\t- (void)postAutomaticLoginNotify;\n\t\n\t@end\n\t\n\t// Not preferred:\n\t\n\t[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(keyboardWillShow:) name:UIKeyboardWillShowNotification object:nil];\n\t\n\t\n2.15 建议：对于某些功能，需要依赖其他的功能才能完成整个过程，可以把这些相互依赖的功能包装成一个独立的方法，便于复用。\n\n\t// 这是登录，包括邮箱登录接口、手机登录接口、用户信息接口、消息提示接口\n\t\n\t// Preferred: \n\t// 该 LogingHelper 类方法包装了登录相关的逻辑和数据的交互\n\t@interface LoginHelper : NSObject\n\n\t+ (void)loginWithUser:(NSString *)username\n\t             Password:(NSString *)password\n    \t       Completion:(void (^)(BOOL success, NSString *errorMsg, Login_Post \t*loginPost,UserInfo_Get *userinfoGet))block;\n\n\t@end\n\t\n\t// Not preferred:\n\t\n\tLogin_Post *loginApi = nil;\n\tif ([username isValidateMobile])\n\t{\n\t\t// 手机登录\n\t\tloginApi = [[Login_Post alloc] initWithAccount:username password:password];\n\t}\n\telse\n\t{\n\t\t// 邮箱登录\n\t\tloginApi = [[Email_Post alloc] initWithAccount:username password:password];\n\t}\n\t\n\tif (llginApi.code != 0)\n\t{\n\t\t// 登录失败，返回\n\t\treturn;\n\t}\n\t\n\tUserInfo_Get *userInfoApi = [[UserInfo_Get alloc] initWithUserId:loginApi.user_id];\n\tif (userInfoApi.code != 0)\n\t{\n\t\t// 获取用户信息失败，返回\n\t\treturn;\n\t}\n\t\n\t// 其他相互依赖的功能....\n\t\n2.15 建议：在使用第三发库的时候，比如 AFNetworking 进行网络请求。可以抽象出一个基类，把网络相关的请求重新封装，通过继承的方式，来复用这些功能。好处就是：需要更新 AFNetworking 库，或者迁移到其他的网络库，只需要修改基类的方法。各种 Loading、下拉刷新......等\n\t\n2.15 建议：所有需要重复使用的代码，都可以包装成一个方法"
        },
        {
            "id": "BE6D156A-57C1-4C75-8E2B-CD1C0487352E",
            "categoryId": 7,
            "userID": "99CAA138-43C1-45D7-9F90-680FB25BCF8D",
            "likeNum": 0,
            "author": "turkeyaa",
            "isGood": 0,
            "authorImage": "8cccd292754f1545724239.6914082.jpg",
            "title": "iOS设计模式",
            "viewNum": 4,
            "createTime": 1545722543,
            "collectNum": 0,
            "replyNum": 0,
            "content": "> 设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的；设计模式使代码编制真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。\n\n包含如下设计模式的概念和实际使用：\n\n1. 原型模式\n2. 工厂方法模式\n3. 抽象工厂模式\n4. 生成器模式\n5. 单例模式\n6. 适配器模式\n7. 桥接模式\n8. 外观模式\n9. 中介者模式\n10. 观察者模式\n11. 组合模式\n12. 迭代器模式\n13. 访问者模式\n14. 装饰模式\n15. 责任链模式\n16. 模板方法模式\n17. 策略模式\n18. 命令模式\n\n`参考书籍《Objective-C 编程之道》`:`Processon 绘制 UML`\n\n***\n\n> 针对接口编程，而不是针对实现编程\n\n1. 只要对象符合客户端所要求的接口，客户端就不必在意所使用对象的确切类型。\n2. 客户端只知道定义接口的协议或者抽象类，因此客户端对对象的类一无所知。\n\n定义具有相同接口的类群很重要，因为多态是基于接口的。Objective-C有一种类似的东西叫做协议，协议是对象之间的一种合约，但本身不能实例化对象。实现协议或者从抽象类继承，使得对象共享相同的接口。有几点好处：\n\n协议并不定义任何实现，而只申明方法，以确定符合协议的类的行为。因此协议只定义了抽象行为的“接口”。实现协议的类定义这些方法的实现，以执行真正的操作。变更协议可能会破坏实现该协议的类，可以使用 @optional 指令，将协议的部分方法变更为“可选的”。\n\n客户端使用由协议所定义类型的对象，有个 Mark 协议，可以这样引用\n\n```\nid <Mark> = thisMark;\n```\n\n抽象基类通过生成一些其他子类可以共享的默认行为，抽象基类与通常的类相似，只是预留了一些可以或应该由子类重写的行为。\n\n如果`Mark`被申明为抽象基类，语法是这样\n\n```\nMark *thisMark;\n```\n\n***\n\n### 对象创建\n\n##### 1. 原型模式：\n\n1.1 原型模式是一种非常简单的设计模式，客户端知道抽象 Prototype 类。在运行时，抽象 Prototype 子类的任何对象都可以按客户端的意愿被复制，因此，无需手工创建就可以制造同一个类型的多个实例。\n\n![原型模式](http://upload-images.jianshu.io/upload_images/1294131-511aa5e25c3cb366..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n1.2 在Objective-C中这样实现，在Prototype类(基类)中定义复制自身的接口，在实际子类中(ConcretePrototype1、ConcretePrototype2...)实现该方法\n\t\n\t// Prototype.h 文件\n\t// 在抽象基类(Prototype)中定义复制自身的接口\n\t\n\t// Subclassing\n\t- (Prototype *)clone;\n\t- (void)print;\n\n\t\n\t// Prototype.m 文件\n\n\t// 基类方法，什么也不做\n\t- (Prototype *)clone {\n\t\tPrototype *typeSelf = [[Prototype alloc] init];\n\t\treturn typeSelf;\n\t}\n\n\t- (void)print {\n\t\tNSLog(@\"This is = %@ class = [%@]\",self,[self class]);\n\t}\n\t\n\t// 在ConcretePrototype1类中重写父类clone方法\n\t- (Prototype *)clone {\n\t\tConcretePrototype1 *typeSelf = [[ConcretePrototype1 alloc] init];\n\t\treturn typeSelf;\n\t}\n\t\n\t// 在客户端这样创建对象\n\tPrototype *type1 = [[ConcretePrototype1 alloc] init];\n    [type1 print];\n    Prototype *newType1 = [type1 clone];\n    [newType1 print];\n\t\n1.3 何时实用原型模式：\n\n1. 需要创建的对象应独立于其他类型与创建方式\n2. 要实例化的类是在运行时决定的\n3. 不想要与产品层次相对应的工厂层次\n4. 不同类的实例间的差异仅是状态的若干组合。因此复制相应数量的原型比手工实例化更加方便\n5. 类不容易创建，比如每个组件可把其他组件作为子节点的组合对象，复制已有的组合对象并对副本进行修改会更加容易\n\t\n***\n\n##### 2. 工厂方法\n\n2.1 工厂方法模式：定义创建对象的接口，让子类决定实例化那一个类，工厂方法使得一个类的实例化延迟到其子类。\n\n2.2 举个例子：对象工厂与生产有形产品的真实工厂类似，例如，制鞋厂生产鞋，手机工厂生产手机。比如你让工厂给你生产些产品。你给它们发送一个 “生产产品的消息”。制鞋厂和手机厂都按照相同的“生产产品”的协议，启动其生产线。过程结束后，每个厂家都返回所生产的特定类型的产品。我们把“生产”这个有魔力的词称作为工厂方法，因为它是命令生产者（工厂）得到想要产品的方法。\n\n![工厂方法模式](http://upload-images.jianshu.io/upload_images/1294131-c4cd2b623478454a..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n2.3 在Objective-C中可以这样写：抽象的 Product（产品）定义了工厂方法创建的对象的接口。ConcreteProduct 实现了 Product 接口。Creator 定义了返回 Product 对象的工厂方法。它也可以为工厂方法定义一个默认实现，返回默认 ConcreteProduct 对象。Creator 的其他操作可以调用此工厂方法创建 Product 对象。ConcreteCreator 是 Creator 的子类。 它重写了工厂方法，以返回 ConcreteProduct 的实例。\n\n\t// 在Creator中定义一个接口\n\t- (Product *)factoryMethod;\n\t\n\t// 返回一个抽象产品\n\t- (Product *)factoryMethod {\n\t\tProduct *product = [[Product alloc] init];\n\t\treturn product;\n\t}\n\t\n\t// 在ConcreteCreator中返回实际产品\n\t- (Product *)factoryMethod {\n\t\tConcreteProduct *product = [[ConcreteProduct alloc] init];\n\t\treturn product;\n\t}\n\t\n\t// 在客户端这样创建产品\n\tProduct *product = [ConcreteCreator factoryMethod];\n\t// 得到ConcreteCreator对象了\n\n2.4 如下情形，会考虑使用工厂方法\n\n1. 编译时无法准确预期要创建的对象的类\n2. 类想让其子类决定在运行时创建什么\n3. 类有若干辅助类为其子类，而你想将返回哪个子类这一信息局部化\n\n> 使用这一模式的一个常见例子是 Cocoa Touch 框架中的 NSNumber。尽管可以使用常见的 alloc init 两步创建 NSNumber 实例，但这没有什么用。除非使用预先定义的类工厂方法来创建有意义的实例。例如 [NSNumber numberWithBool:YES] 消息会得到 NSNumber 的子类 NSCFBoolean 的一个实例。\n \n***\n\n##### 3. 抽象工厂\n\n1. 通过对象组合创建抽象产品\n2. 创建多系列产品\n3. 必须修改父类的接口才能支持新的产品\n\n3.1 抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类或其创建的细节。客户端与从工厂得到的具体对象之间没有耦合\n\n![抽象工厂模式](http://upload-images.jianshu.io/upload_images/1294131-2551625de2fd5528..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n***\n\n##### 4. 生成器\n\n4.1 生成器模式：将一个复杂对象的构建与它的表现分离，使得同样的构建过程可以创建不同的表现\n\n4.2 Build 是一个抽象接口，申明了一个 buildPart 方法，该 builder 方法由 ConcreteBuilder 实现，以构造实际产品(Product)。ConcreteBuilder 有个 getResult 方法，向客户端返回构造完毕的 Product，Director 定义了一个 construct 方法，命令 Builder 的实例去 buildPart。 Director和Builder形成一种聚合关系。这意味着 Builder 是一个组成部分，与 Director 结合。以使整个模式运转，但同时，Director 并不负责 Builder 的生存期。\n\n![生成器模式](http://upload-images.jianshu.io/upload_images/1294131-d578bde24d8ce404..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n4.3 何时实用生成器模式:\n\n1. 构建复杂对象\n2. 以多个步骤构建对象\n3. 以多种方式构建对象\n4. 在构建过程的最后一步返回产品\n5. 专注一个特定产品\n\n***\n\n##### 5. 单例\n\n5.1 单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。也是最简单的一种模式。\n\n![单例模式](http://upload-images.jianshu.io/upload_images/1294131-e1bb42dcd8208988..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n5.2 在Objective-C中可以通过GCD的方式来实现\n\n\t+ (Singleton *)sharedInstance {\n    \n\t\tstatic Singleton *_instance = nil;\n    \n\t\tstatic dispatch_once_t onceToken;\n\t\tdispatch_once(&onceToken, ^{\n\t\t\t// 默认实现\n\t\t\t_instance = [[Singleton alloc] initWithSingleton];\n\t\t\t// 支持子类化\n\t\t\t_instance = [[super allocWithZone:NULL] initWithSingleton];\n\t\t});\n\t\treturn _instance;\n\t}\n\n5.3 何时使用单例模式：\n\n1. 访问共享对象，比如：文件系统、控制类、管理类、配置信息类。在Cocoa Touch中，`UIApplication`通过单例类设计\n\n***\n\n### 接口适配\n\n##### 6. 适配器\n\n6.1 适配器模式：将一个类的接口转换成客户端希望的另外一个接口。适配器模式使得由于接口不兼容而不能在一起工作的那些类可以一起工作。用于连接两种不同种类的对象，使其毫无问题的协同工作，有时称为包装器。包括类适配器和对象适配器。\n\n![适配器模式](http://upload-images.jianshu.io/upload_images/1294131-db1aba4fc98c5e64..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n6.2 包含：类适配器和对象适配器。代理(Delegate)模式属于对象适配器\n\n> 类适配器\n\n1. 只针对单一具体的 Adaptee 类，把 Adaptee 适配到 Target\n2. 易于重载 Adaptee 的行为，因为是通过直接的子类化进行的适配\n3. 只有一个 Adapter 对象，无须额外的指针间接访问 Adaptee\n\n> 对象适配器\n\n1. 可以适配多个 Adaptee 及其子类\n2. 难以重载 Adaptee 的行为，需要借助于子类的对象而不是 Adaptee 本身\n3. 需要额外的指针以间接访问 Adaptee 并适配其行为\n\n6.3 使用场景\n\n1. 已有类的接口与需求不匹配。\n2. 想要一个可复用的类，该类能够同可能带有不兼容接口的其他类协作。\n3. 需要适配一个类的几个不同子类，可是让每一个子类去子类化一个类适配器又不现实，那么可以使用对象适配器(也叫委托)来适配其父类的接口。\n\n6.4 用Objective-C的块实现适配器模式。在我们的项目中，有一个视图，它允许用户改变在CanvasView中绘图的颜色和线宽。视图中有3个滑动条，用于改变线色的颜色份量。这一操作涉及几个组件---CanvasViewController、PaletteViewController及其滑动条。我们需要一个更好的方案，让我们能够把颜色变更的部分复用到应用程序的其他地方。\n\n![Block实现适配器模式](http://upload-images.jianshu.io/upload_images/1294131-8953312de17f7d6d..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n从图中可看到，定义了一个叫RGBValuesProvider的块，签名为CGFloat ^(CGFloat *red, CGFloat *green, CGFloat *blue)。块字面量应该符合块签名，并提供某些处理的实现。\n\n> Command.h 代码清单\n\n\t@interface Command : NSObject\n\n\t{\n\t\t@protected\n\t\t// 其他一些私有成员变量\n\t}\n\n\t// 其他属性...\n\n\t- (void)execute;\n\n\t@end\n\n\n> SetStrokeColorCommand.h 代码清单\n\t\n\t#import \"Command.h\"\n\t\n\ttypedef void(^RGBValuesProvider)(CGFloat *red, CGFloat *green, CGFloat *blue);\n\n\t@interface SetStrokeColorCommand : Command\n\n\t@property (nonatomic, copy) RGBValuesProvider valuesProvider;\n\n\t- (void)execute;\n\n\t@end\n\n> SetStrokeColorCommand.m 代码清单\n\t\n\t- (void)execute {\n    \n\t\tCGFloat redValue = 0.0;\n\t\tCGFloat greenValue = 0.0;\n\t\tCGFloat blueValue = 0.0;\n    \n\t\t// 从块中取得 RGB 值\n\t\tif (_valuesProvider != nil) {\n\t\t\t_valuesProvider(&redValue,&greenValue,&blueValue);\n\t\t}\n\t\t// 根据 RGB 值创建一个颜色对象\n\t\tUIColor *color = [UIColor colorWithRed:redValue green:greenValue blue:blueValue alpha:1.0];\n    \n\t\t// 把它赋值给当前 canvasViewController\n\t\tCanvasViewController *vc = [[CoordinatingController sharedInstance] canvasVC];\n\t\tvc.view.backgroundColor = color;\n\t}\n\t\n> CommandSlider.h 代码清单\n\t\n\t#import \"Command.h\"\n\t\n\t@interface CommandSlider : UISlider\n\t{\n\t\t@protected\n\t\tCommand *_command;\n\t}\n\n\t@property (nonatomic, strong) Command *command;\n\n\t@end\n\t\n> PaletteViewController.m 中的 viewDidLoad方法\n\t\n\tSetStrokeColorCommand *colorCommand = [[SetStrokeColorCommand alloc] init];\n\tcolorCommand.valuesProvider = ^(CGFloat *red, CGFloat *green, CGFloat *blue) {\n        *red = [_redSlider value];\n        *green = [_greenSlider value];\n        *blue = [_blueSlider value];\n\t};\n\t\n> PaletteViewController.m 用于所有CommandSlider实例的valueChange：事件处理器\n\n\t#pragma mark - \n\t#pragma mark Slider evnet handler\n\t- (void)updateColor:(CommandSlider *)slider {\n\t\t[[slider command] execute];\n\t}\t\n\t\n***\n\n##### 7. 桥接\n\n7.1 桥接模式的目的是把抽象层次结构从其实现中分离出来，使其能够独立变更。抽象层定义了供客户端使用的上层的抽象接口。实现类的引用被封装于抽象层的实例中时，桥接就形成了。\n\n![桥接模式](http://upload-images.jianshu.io/upload_images/1294131-c390194c5c507f84..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n7.2 Abstraction是定义了供客户端使用的上层抽象接口的父接口。它有一个对Implementor实例的引用，Implement定义了实现类的接口。这个接口不必跟Abstraction的接口一致。Implement的接口提供基本的操作，而Abstraction的上层操作基于这些基本操作。当客户端向Abstraction的实例发送operation消息时，这个方法向imp发送operationImp消息。底下的实际ConcreteImplementator(A或B)将做出相应并接受任务。\n\n7.3 因此想要往系统中添加新的ConcreteImplementator时，所要做的只是为Implementor创建一个新的实现类，相应operationImp消息并在其中执行任何具体的操作。不过，这对Abstraction方面不会有任何影响。同样，如果想修改Abstraction的接口或者创建更细化的Abstraction类，也能做到不影响桥接的另一头。\n\n7.4 何时实用桥接模式\n\n1. 不想在抽象与其实现之间形成固定的绑定关系(这样就能在运行时切换实现)\n2. 抽象及其实现都应可以通过子类化独立进行扩展\n3. 对抽象的实现进行修改不应影响客户端代码\n4. 如果每个实现需要额外的子类以细化抽象，则说明有必要把它们分成两个部分\n5. 想在带有不同抽象接口的多个对象之间共享一个实现。\n\n7.5 创建iOS版虚拟仿真器\n\n![桥接_仿真器](http://upload-images.jianshu.io/upload_images/1294131-b8193101a58b63e3..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n7.6 ConsoleController和ConsoleEmulator分别是虚拟控制器和仿真器的抽象类。两个类有不同的接口。在ConsoleController中封装一个对ConsoleEmulator的引用，是联系两者的唯一方式。因此ConsoleController的实例可以在一个抽象层上使用ConsoleEmulator的实例。这就形成了两个不同的类ConsoleController和ConsoleEmulator之间的桥接。ConsoleEmulator为其子类定义了接口，用于处理针对特定控制台OS的底层指令。ConsoleController的setCommand:command消息把它传递给内嵌的ConsoleEmulator引用。最后，它向这个引用发送一个executeInstructions消息，在仿真器中执行任何已加载的指令。\n\n7.7 ConsoleController类层次结构代表对ConsoleEmulator类层次结构的任何“实现”的一种抽象。抽象类层次结构提供了一层抽象，形成一个对任何兼容ConsoleEmulator的虚拟控制层。具体的ConsoleController只能通过在父类中定义的底层setCommand:方法，与桥接的另一端的仿真器进行交流。在这种配置中这个方法不应被子类重载，因为这是一个让父类与细化的控制器之间进行通讯的接口。如果在仿真器的一侧发生变更，对左侧的任何控制器都将毫无影响，反之亦然。\n\n> 代码清单 ConsoleCommands.h \n\n\ttypedef enum {\n\t\tkConsoleCommandUp,\n\t\tkConsoleCommandDown,\n\t\tkConsoleCommandLeft,\n\t\tkConsoleCommandRight,\n\t\tkConsoleCommandSelect,\n\t\tkConsoleCommandStart,\n\t\tkConsoleCommandAction,\n\t\tkConsoleCommandAction2, \n\t} ConsoleCommand;\n\t\n上、下、左、右、选择、开始、动作1和动作2作为通用命令，定义一组enum。要是将来想扩展命令列表，以支持更复杂的模拟器，都不会破坏任何一边的设计。\t\n\n> 代码清单 ConsoleEmulator.h\n\t\n\t#import \"ConsoleCommands.h\"\n\n\t@interface ConsoleEmulator : NSObject\n\n\t- (void)loadInstructionsForCommand:(ConsoleCommand)command;\n\t- (void)executeInstructions;\n\n\t// 其他行为和属性\n\n\t@end\n\t\n> 代码清单 GameBoyEmulator.h\n\t\n\t@interface GameBoyEmulator : ConsoleEmulator\n\t\n\t// 从抽象类重载的行为\n\t- (void)loadInstructionsForCommand:(ConsoleCommand)command;\n\t- (void)executeInstructions;\n\n\t@end\n\t\nGameBoyEmulator和GameGearEmulator都是ConsoleEmulator的子类。他们重载抽象方法，并提供自己平台的特定行为。\n\n> 代码清单 ConsoleController.h\n\n\t#import \"ConsoleEmulator.h\"\n\n\t@interface ConsoleController : NSObject\n\n\t@property (nonatomic, strong) ConsoleEmulator *emulator;\n\n\t- (void)setCommand:(ConsoleCommand)command;\n\n\t// 其他行为和属性\n\n\t@end\n\nConsoleController是整个虚拟控制器类层次的起点，它以emulator_保持着ConsoleEmulator实例的一个内部引用。它也定义了一个setCommand:command方法，供其子类用预先定义的命令类型输入命令。\n\n> 代码清单 ConsoleController.m\n\n\t- (void)setCommand:(ConsoleCommand)command {\n\t\t[_emulator loadInstructionsForCommand:command];\n\t\t[_emulator executeInstructions];\n\t}\n\t\n到此，虚拟控制器与仿真器的基本桥接就完成了。现在要开始创建第一个虚拟控制器TouchConsoleController，以形成多点触摸屏与隐藏在视图之后具体仿真器之间的接口。\n\n> 代码清单 TouchConsoleController.h\n\t\n\t@interface TouchConsoleController : ConsoleController\n\n\t- (void)up;\n\t- (void)down;\n\t- (void)left;\n\t- (void)right;\n\t- (void)select;\n\t- (void)start;\n\t- (void)action1;\n\t- (void)action2;\n\n\t@end\n\t\n> 代码清单 TouchConsoleController.m\n\t\n\t@implementation TouchConsoleController\n\n\t- (void)up {\n\t\t[super setCommand:kConsoleCommandUp];\n\t}\n\t- (void)down {\n\t\t[super setCommand:kConsoleCommandDown];\n\t}\n\t- (void)left {\n\t\t[super setCommand:kConsoleCommandLeft];\n\t}\n\t- (void)right {\n\t\t[super setCommand:kConsoleCommandRight];\n\t}\n\t- (void)select {\n\t\t[super setCommand:kConsoleCommandSelect];\n\t}\n\t- (void)start {\n\t\t[super setCommand:kConsoleCommandStart];\n\t}\n\t- (void)action1 {\n\t\t[super setCommand:kConsoleCommandAction];\n\t}\n\t- (void)action2 {\n\t\t[super setCommand:kConsoleCommandAction2];\n\t}\n\n\t@end\n\t\n> 客户端代码 viewDidLoad方法\n\t\n\t// ConsoleEmulator *emulator = [[GameBoyEmulator alloc] init];\n\tConsoleEmulator *emulator = [[GameGearEmulator alloc] init];\n    \n\tTouchConsoleController *control = [[TouchConsoleController alloc] init];\n\tcontrol.emulator = emulator;\n\t[control up];  // left、right、action1.....等命令\n\t\n***\n\n##### 8. 外观\n\n8.1 外观模式：为子系统中一组不同的接口提供统一的接口。外观定义了上层接口，通过降低复杂度和隐藏子系统间的通信及依存关系，让子系统更易于使用。\n\n![外观模式](http://upload-images.jianshu.io/upload_images/1294131-85a73b537e112664..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n8.2 可以看到整个出租车服务作为一个封闭系统，包括出租车司机、一辆车和一台计价器。同系统交互的唯一途径是通过CabDriver中定义的接口driveToLocation:x。一旦乘客向出租车司机发出driveToLocation:消息，CabDriver就会收到这个消息。司机需要操作两个子系统---Taximeter和Car。CabDriver先会启动(start)Taximeter，让它开始计价，然后司机对汽车会松刹车(releaseBrakes)、换挡(changeGears)...停止(stop)，Taximeter，结束行程。一切都发生于发送CabDriver的一个简单的driveToLocation:x命令之中。无论这两个子系统有多么复杂，他们隐藏于乘客的视线之外。因此CabDriver是在为出租车子系统的其他复杂接口提供一个简化的接口。\n\n> 代码清单 Car.h\n\t\n\t@interface Car : NSObject\n\n\t- (void)releaseBrakes;\n\t- (void)changeGears;\n\t- (void)pressAccelerator;\n\t- (void)pressBrakes;\n\t- (void)releaseAccelerator;\n\t- (void)stop;\n\n\t@end\n\n> 代码清单 Taximeter.h\n\t\n\t@interface Taximeter : NSObject\n\n\t- (void)start;\n\t- (void)stop;\n\n\t@end\n\t\n> 代码清单 CabDriver.h\n\t\n\t@interface CabDriver : NSObject\n\n\t- (void)driveToLocation:(CGPoint)x;\n\n\t@end\n\n> 代码清单 CabDriver.m\n\t\n\t- (void)driveToLocation:(CGPoint)x {\n\t\t// ...\n    \n\t\t// 启动计价器\n\t\tTaximeter *meter = [[Taximeter alloc] init];\n\t\t[meter start];\n    \n\t\t// 操作车辆，直到抵达位置 x\n\t\tCar *car = [[Car alloc] init];\n\t\t[car releaseBrakes];\n\t\t[car changeGears];\n\t\t[car pressAccelerator];\n    \n\t\t// ......\n    \n\t\t// 当到达了位置 x，就停下车和计价器\n\t\t[car releaseAccelerator];\n\t\t[car pressBrakes];\n\t\t[meter stop];\n\t}\n\t\n> 代码清单，客户端代码 \tviewDidLoad方法\n\t\n\tCabDriver *driver = [[CabDriver alloc] init];\n\t[driver driveToLocation:CGPointMake(100.0, 100.0)];\n\t\n\t\n8.3 使用场景\n\n1. 子系统正逐渐变得复杂，应用模式的过程中演化出许多类。可以使用外观为这些子系统类提供一个简单的接口。\n2. 可以使用外观对子系统进行分层，每个子系统级别有一个外观作为入口点。让它们通过其外观进行通信，可以简化它们的依存关系。\t\n\n***\n\n### 对象去耦\n\n##### 9. 中介者\n\n9.1 中介者模式是用一个对象来封装一些列对象的交互方式。中介者使各对象不需要显示地相互引用，从而使其耦合松散，而且可以独立的改变它们之间的交互。\n\n![中介者模式](http://upload-images.jianshu.io/upload_images/1294131-774b9e280e440e32..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n9.2 抽象的 Mediator 定义了用于同 Colleague 交互的一般行为，典型的同事(colleague)是以明确定义的方式进行相互通信的对象，并且彼此紧密依存，ConcreteMediator 为 ConcreteColleague定义了更加具体的行为。如果应用程序只需要一个中介者，有时抽象 Mediator 可以省略。\n\n9.3 使用场景\n\n1. 对象间的交互虽定义明确然而非常复杂，导致一组对象彼此相互依赖而且难以理解。\n2. 因为对象引用了许多其他对象并与其通讯，导致对象难以复用\n3. 想要定制一个分布在多个类中的逻辑与行为，又不想生成太多子类\n\n\n##### 10. 观察者\n\n10.1 观察者模式：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更行。\n\n![观察者模式](http://upload-images.jianshu.io/upload_images/1294131-b2530e4b9ab39ce2..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n10.1 观察者模式是一种发布-订阅模型。Observer从Subject订阅通知。ConcreteObserver实现抽象Observer并重载update方法。一旦Subject的实例需要通知Observer任何新的变更，Subject会发送update消息并通知存储内部列表中所有注册的Observer。在ConcreteObserver的update方法的实例实现中，Subject内部状态可被取得并在以后进行处理。\n\n10.2 Subject提供注册与取消注册的方法，任何实现了Observer协议而且想要处理update消息的对象，都可以进行注册或取消注册。当Subject的实例发生变更时，它会想自己发送notify消息。notify方法里有个算法，定义了如何向已注册的观察者广播update消息。\n\n10.3 何时使用观察者模式\n\n1. 有两种抽象类型相互依赖。将它们封装在各自的对象中，就可以对它们单独进行改变和复用。\n2. 对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变\n3. 一个对象必须通知其他对象，而它又不需要知道其他对象是什么\n\n10.4 在Cocoa Touch框架中使用观察者模式：通知和键-值观察\n\n10.4.1 通知\n\nCocoa Touch框架使用NSNotificationCenter和NSNotification对象实现了一对多的发布-订阅模型。它们允许主题与观察者以一种松耦合的方式通信。两者在通信时对另一方无需多少了解。\n\n主题要通知其他对象时，需要创建一个可通过全局的名字来识别的通知对象，然后把它投递到通知中心。通知中心查明特定的观察者，然后通过消息把通知发送给它们。\n\n一旦创建了通知，就用它作为[notificationCenter postNotification:notification]消息调用的参数，投递到通知中心。通过向NSNotificationCenter类发送defaultCenter消息，可以得到NSNotificationCenter实例的引用。每个进程只有一个默认的通知中心，所以默认的NSNotificationCenter是个单例对象。defaultCenter是返回应用程序中NSNotificationCenter的唯一默认实例的工厂方法\n\n模型可以这样构造一个通知然后投递到通知中心\n\t\n\tNSNotification *notification = [NSNotification notificationWithName:@\"data changes\" object:self];\n\tNSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];\n    \n\t// 发送通知\n\t[notificationCenter postNotification:notification];\n    \n\t// 订阅通知\n\t[notificationCenter addObserver:self selector:@selector(update:) name:@\"data changes\" object:subject];\n\t\n\t// 删除通知\n\t[notificationCenter removeObserver:self name:@\"data changes\" object:nil];\n\n10.4.2 键-值观察\n\n是一种通知机制，它使对象能够在其他对象的属性发生更改时获得通知。在观察对象和被观察对象之间建立了联系。当被观察对象属性的值发生改变时，会想观察者发送一对一的通知。\n\n这一机制基于NSKeyValueObserving非正式协议，Cocoa通过这个协议为所有遵守协议的对象提供了一种自动化的属性观察能力。要实现自动观察，参与键-值观察(Key-Value Observing，KVO)的对象需要符合键-值编码(KVC)的要求，并且需要符合KVC的存储方法。KVC基于有关非正式协议，通过存储对象属性实现自动观察。也可以使用NSKeyValueObserving的方法和相关范畴来实现手动的观察者通知。\n\t\n\t// 监听Person实例对象（person）的name属性变化\n\t[person addObserver:self forKeyPath:@\"name\" options:NSKeyValueObservingOptionNew context:nil]\n\t\n\t// 然后实现该方法就可以得到属性的变更通知\n\t- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary<NSKeyValueChangeKey,id> *)change context:(void *)context {\n\t\tNSLog(@\"keyPath = %@\",keyPath);\n\t\tNSLog(@\"change = %@\",change);\n\t}\n\t\n10.4 通知和键-值观察的主要却别\n\n| 通知        \t\t\t\t\t\t\t      | 键-值观察                       |\n| --------------------------------------- |:------------------------------:|\n| 一个中心对象为所有观察者提供变更通知          | 被观察的对象直接向观察者发送通知     |\n| 主要从广义上关注程序事件      \t\t\t     |绑定于特定对象属性的值               |\n\n\t\n***\n\n### 抽象集合\n\n##### 11. 组合\n\n11.1 组合模式：将对象组合成树形结构以表示\"部分-整体\"的层次结构。组合使得用户对单个对象和组合对象的使用具有一致性\n\n![组合模式](http://upload-images.jianshu.io/upload_images/1294131-a6bf875f204e0598..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n基类接口是定义了Leaf类和Composite类的共同操作的Component\n\n每个节点代表一个叶节点或组合体节点。Leaf节点与Composite节点的主要区别在于，Leaf节点不包含同类型的子节点，而Composite则包含。Composite包含同一类型的子节点。由于Leaf类与Composite类有同样的接口，任何对Component类型的操作也能安全地应用到Leaf和Composite。客户端就不需要根据确切类型的is-else语句。\n\nComposite需要方法来管理子节点，比如add:component和remove:component。因为Leaf和Composize有共同的接口，这些方法必须也是接口的一部分。而向Leaf对象发送组合体操作消息则没有意义，也不起作用，只有默认的实现。\n\n11.2 使用场景\n\n1. 想获得对象抽象的树形表示(部分-整体层次结构)\n2. 想让客户端统一处理组合结构中的所有对象\n\n11.3 在Cocoa Touch框架中使用组合模式\n\n![组合模式](http://upload-images.jianshu.io/upload_images/1294131-f63b46c4ff8dc32f..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) \n\nMark协议是Dot、Vertex、Stroke类型的基类型，这样它们具有相同的接口。Dot的实例可以画在视图上，而Stroke的子节点Vertext对象只用来帮助在同一线条中把线连接起来。\n\nVertex只实现了location属性。Dot子类化Vertext并增加color与size属性，因为Vertex不需要color和size而Dot需要。在运行时aStroke可以包含aDot或aVertex对象。因此Stroke对象既可以是各种Mark的父节点，也可以是由Vertex对象构成的真正的线条组合，作为一个整体绘制在屏幕上。\n\n> 代码清单 Mark.h\n\t\n```\n\n@protocol Mark <NSObject>\n\n@property (nonatomic, strong) UIColor *color;\n@property (nonatomic, assign) CGFloat size;\n@property (nonatomic, assign) CGPoint location;\n@property (nonatomic, readonly) NSUInteger count;       // 子节点的个数\n@property (nonatomic, readonly) id<Mark>lastChild;\n\n- (id)copy;\n- (void)addMark:(id<Mark>)mark;\n- (void)removeMark:(id<Mark>)mark;\n- (id<Mark>)childMarkAtIndex:(NSUInteger)index;\n\n- (void)drawWithContext:(CGContextRef)context;\n\n@end\n\n```\n\n\n> 代码清单 Vertex.h\n\t\n```\n\n@interface Vertex : NSObject <Mark,NSCopying>\n\n{\n    @protected\n    CGPoint location_;\n}\n\n@property (nonatomic, strong) UIColor *color;\n@property (nonatomic, assign) CGFloat size;\n@property (nonatomic, assign) CGPoint location;\n@property (nonatomic, readonly) NSUInteger count;       // 子节点的个数\n@property (nonatomic, readonly) id<Mark>lastChild;\n\n- (id)initWithLocation:(CGPoint)location;\n- (void)addMark:(id<Mark>)mark;\n- (void)removeMark:(id<Mark>)mark;\n- (id<Mark>)childMarkAtIndex:(NSUInteger)index;\n\n- (void)drawWithContext:(CGContextRef)context;\n\n@end\n\n\n```\n\n\n> 代码清单 Vertex.m\n\n```\n\n@synthesize location = location_;\n@dynamic color,size;\n\n- (id)initWithLocation:(CGPoint)location {\n    if (self = [super init]) {\n        [self setLocation:location];\n    }\n    return self;\n}\n\n// 默认属性什么也不做\n- (void)setColor:(UIColor *)color {}\n- (UIColor *)color {return nil;}\n- (void)setSize:(CGFloat)size {}\n- (CGFloat)size {return 0.0;}\n\n// Mark 操作什么也不做\n- (void)addMark:(id<Mark>)mark {}\n- (void)removeMark:(id<Mark>)mark {}\n- (id<Mark>)childMarkAtIndex:(NSUInteger)index {return nil;}\n- (id<Mark>)lastChild {return nil;}\n\n// 绘图，一个顶点\n- (void)drawWithContext:(CGContextRef)context {\n    CGFloat x = self.location.x;\n    CGFloat y = self.location.y;\n    \n    CGContextAddLineToPoint(context, x, y);\n}\n\n\t#pragma mark -\n\t#pragma mark - NSCopying method\n// 此方法需要实现，以支持备忘录\n- (id)copyWithZone:(NSZone *)zone {\n    Vertex *vertexCopy = [[[self class] allocWithZone:zone] initWithLocation:location_];\n    return vertexCopy;\n}\n\n```\n\n\n> 代码清单 Dot.h\n\n\n```\n\n@interface Dot : Vertex\n\n{\n    @private\n    UIColor *color_;\n    CGFloat size_;\n}\n\n@property (nonatomic, strong) UIColor *color;\n@property (nonatomic, assign) CGFloat size;\n\n- (void)drawWithContext:(CGContextRef)context;\n\n@end\n\n```\n\n\n> 代码清单 Dot.m \n\n```\n\n@synthesize size = size_, color = color_;\n\n- (void)drawWithContext:(CGContextRef)context {\n    CGFloat x = self.location.x;\n    CGFloat y = self.location.y;\n    CGFloat frameSize = self.size;\n    CGRect frame = CGRectMake(x, y, frameSize, frameSize);\n    \n    CGContextSetFillColorWithColor(context, [self color].CGColor);\n    CGContextFillEllipseInRect(context, frame);\n}\n\n\t\t#pragma mark - \n\t\t#pragma mark - NSCopying method\n- (id)copyWithZone:(NSZone *)zone {\n    Dot *dotCopy = [[[self class] allocWithZone:zone] initWithLocation:location_];\n    // 复制 color\n    [dotCopy setColor:[UIColor colorWithCGColor:[color_ CGColor]]];\n    // 复制 size\n    [dotCopy setSize:size_];\n    return dotCopy;\n}\n\n\n```\n\n\n> 代码清单 Stroke.h\n\n```\n\n@interface Stroke : NSObject <Mark,NSCopying>\n\n{\n    @private\n    UIColor *color_;\n    CGFloat size_;\n    NSMutableArray *children_;\n}\n\n@property (nonatomic, strong) UIColor *color;\n@property (nonatomic, assign) CGFloat size;\n@property (nonatomic, assign) CGPoint location;\n@property (nonatomic, readonly) NSUInteger count;\n@property (nonatomic, readonly) id<Mark>lastChild;\n\n- (void)addMark:(id<Mark>)mark;\n- (void)removeMark:(id<Mark>)mark;\n- (id<Mark>)childMarkAtIndex:(NSUInteger)index;\n\n- (void)drawWithContext:(CGContextRef)context;\n\n@end\n\n\n```\n\n\n> 代码清单 Stroke.m\n\n\n```\n\n@implementation Stroke\n\n@synthesize color = color_,size = size_;\n@dynamic location;\n\n- (id)init {\n    if (self = [super init]) {\n        children_ = [[NSMutableArray alloc] init];\n    }\n    return self;\n}\n\n- (void)setLocation:(CGPoint)location {\n    // 不做任何位置设定\n}\n- (CGPoint)location {\n    // 返回第一个节点的位置\n    if ([children_ count] > 0) {\n        id<Mark>child = children_[0];\n        return [child location];\n    }\n    // 否则，返回原点\n    return CGPointZero;\n}\n\n- (void)addMark:(id<Mark>)mark {\n    [children_ addObject:mark];\n}\n- (void)removeMark:(id<Mark>)mark {\n    // 如果 mark 在这一层，将其移除并返回\n    // 否则，让每个自己点去找它\n    if ([children_ containsObject:mark]) {\n        [children_ removeObject:mark];\n    }\n    else {\n        [children_ makeObjectsPerformSelector:@selector(removeMark:) withObject:mark];\n    }\n}\n- (id<Mark>)childMarkAtIndex:(NSUInteger)index {\n    if (index >= [children_ count]) {\n        return nil;\n    }\n    return children_[index];\n}\n\n// 返回最后子节点的便利方法\n- (id<Mark>)lastChild {\n    return [children_ lastObject];\n}\n// 返回子节点个数\n- (NSUInteger)count {\n    return [children_ count];\n}\n\n- (void)drawWithContext:(CGContextRef)context {\n    CGContextMoveToPoint(context, self.location.x, self.location.y);\n    for (id<Mark>mark in children_) {\n        [mark drawWithContext:context];\n    }\n    CGContextSetStrokeColorWithColor(context, [self color].CGColor);\n}\n\n\t\t#pragma mark -\n\t\t#pragma mark - NSCopying method\n- (id)copyWithZone:(NSZone *)zone {\n    Stroke *strokeCopy = [[[self class] allocWithZone:zone] init];\n    // 复制 color\n    [strokeCopy setColor:[UIColor colorWithCGColor:[color_ CGColor]]];\n    // 复制 size\n    [strokeCopy setSize:size_];\n    // 复制 children\n    for (id<Mark>child in children_) {\n        id<Mark>childCopy = [child copy];\n        [strokeCopy addMark:childCopy];\n    }\n    return strokeCopy;\n}\n\n```\n\nStroke用自己的children_作为NSMutableArray的实例，来保存Mark子节点。\n\n> 代码清单，客户端构造Mark组合体\n\n```\n\nDot *singleDot = [[Dot alloc] initWithLocation:thisPoint];\nVertex *vertex = [[Vertex alloc] initWithLocation:thisPoint];\n\nStroke *newStroke = [[Stroke alloc] init];\n\n[newStroke addMark:singleDot];\n[newStroke addMark:vertex];\n\nStroke *parentStroke = [[Stroke alloc] init];\n[parentStroke addMark:newStroke];\n[parentStroke addMark:singleDot];\n\n```\n\n单个Dot对象可被添加到parentStroke作为叶节点。parentStroke也可以接受组合体Stroke对象，组合体Stroke对象为了让绘图算法绘制相连的线，管理者自己的Vertex子节点。\n\n***\n\n##### 12. 迭代器\n\n12.1 迭代器提供了一种顺序访问聚合对象(集合)中元素的方法，而无需暴露结构的底层表示和细节。\n\n![迭代器模式](http://upload-images.jianshu.io/upload_images/1294131-b795b2c9733c47b7..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n12.2 List定义了修改集合以及返回集合中元素个数的方法。ListIterator保持一个对List对象的引用，以便迭代器遍历结构中的元素并将其返回。ListIterator定义了让客户端从迭代过程中访问下一项的方法。迭代器有个内部的index_变量，记录集合中的当前位置。\n\n12.3 在Cocoa Touch框架中使用迭代器模式，通过\"枚举器/枚举\"改写了迭代器模式。\n\n通过NSEnumerator来枚举NSArray、NSDictionary和NSSet对象中的元素。NSEnumerator本身是个抽象类。它依靠几个工厂方法，如：objectEnumerator或keyEnumerator，来创建并返回相应的具体枚举器对象。客户端用返回的枚举器对象遍历集合中的元素，\n\n\tNSArray *array = @[@\"one\",@\"two\",@\"three\"];\n\tNSEnumerator *itemEnumerator = [array objectEnumerator];\n    \n\tNSString *item;\n\twhile (item = [itemEnumerator nextObject]) {\n\t\t// 对 item作处理 \n\t}\n\t\n基于块的枚举，更加方便\n\n\t[array enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {\n        \n\t\tNSString *item = obj;\n\t\tif ([item isEqualToString:@\"two\"]) {\n\t\t\t// 终止枚举\n\t\t\t*stop = YES;\n\t\t}\n\t}];\n\t\n12.2 何时实用迭代器模式\n\n1. 需要访问组合对象的内容，而又不暴露其内部表示\n2. 需要通过多种方式遍历组合对象\n3. 需要提供一个统一的接口，用来遍历各种类型的组合对象\t\n\n***\n\n### 行为扩展\n\n##### 13. 访问者\n\n13.1 访问者模式：表示一个作用于某对象结构中的各元素的操作。它让我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。\n\n![访问者模式](http://upload-images.jianshu.io/upload_images/1294131-ef1f62f271c3ddd2..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n13.2 访问者模式涉及两个关键角色(或者组件)：访问者和它访问的元素。元素可以是任何对象，但通常是\"部分-整体\"结构中的结点(组合模式)。部分-整体结构包含组合体与叶节点，或者任何其他复杂的对象结构。元素本身不仅限于这些种类的结构。访问者知道复杂结构中的每个元素，可以访问每个元素的结点，并根据元素的特征、属性或操作，执行任何操作。\n\n13.3 Visitor协议声明了两个很像的 visit 方法，用于访问和处理各种Element类型的对象。ConcreteVisitor（1或2）实现这一协议及其抽象方法。 visit 的操作定义了针对特定Element类型的适当操作。Client创建ConcreteVisit（1或2）的对象，并将其传给一个Element对象结构。Element对象结构中有一个方法接受一般化的Visitor类型。继承Element的类中，所有acceptVisitor方法中的操作几乎一样，只有一条语句，让Visitor对象访问发起调用的具体Element对象。实际使用的 visit 消息，定义在每个具体Element类中，这是具体Element类之间的唯一不同之处。每当把acceptVisitor：消息传给Element结构，这个消息就会被转发给每个结点。在运行时确定Element对象的实际类型，再根据实际类型决定该调用哪个visit*方法\n\n13.4 何时实用访问者模式\n\n1. 一个复杂的对象结构包含很多其他对象，它们有不同的接口(比如组合体)，但是想对这些对象实施一些依赖于其具体类型的操作。\n2. 需要对一个组合结构中的对象进行很多不相关的操作，但是不想让这些操作“污染”这些对象的类。可以将相关的操作集中起来，定义在一个访问者类中，并在需要在访问者中定义的操作时使用它\n3. 定义复杂结构的类很少做修改，但经常需要向其添加新的操作。\n\n***\n\n##### 14. 装饰\n\n14.1 装饰模式：动态地给一个对象添加一些额外的职责。就扩展功能来说，装饰模式相比生成子类更为灵活。\n\n![装饰模式](http://upload-images.jianshu.io/upload_images/1294131-e8c2d95cfd115fce..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n14.2 标准的装饰模式包括一个抽象Component父类，它为其他具体组件(component)声明一些操作。抽象的Component类可被细化为另一个叫做Decorator的抽象类。Decorator包含了另一个Component的引用。ConcreteDecorator为其他Component或Decorator定义了几个扩展行为。并且会在自己的操作中执行内嵌的Component操作。\n\n14.3 Component定义了一些抽象操作，其具体类将进行重载以实现自己特定的操作。Decorator是一个抽象类，它通过将一个Component或Decorator内签到Decorator对象，定义了扩展这个Component的实例的“装饰性”行为。默认的operation方法只是想内嵌的component发送一个消息。ConcreteDecoratorA和ConcreteDecoratorB重载父类的operation，通过super把自己增加的行为扩展给component的operation。如果只需要向component添加一种职责，那么就可以省掉抽象的Decorator类，让ConcreteDecorator直接把请求转发给component。\n\n14.4 何时实用装饰模式\n\n1. 想要在不影响其他对象的情况下，以动态、透明的方法给单个对象添加职责\n2. 想要扩展一个类的行为，却做不到。类定义可能被隐藏，无法进行子类化；或者，对类的么个行为的扩展，为支持每种功能组合，将产生大量的子类\n3. 对类的职责的扩展是可选的\n\n##### 15. 责任链\n\n15.1 责任链模式：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间发生耦合。此模式将这些对象连成一条链，并沿着这条链传递请求，直到有一个对象处理它为止\n\n[站外图片上传中...(image-e9d563-1520217476674)]\n\n15.2 责任链模式的主要思想是，对象引用了同一类型的另一个对象，形成一条链。链中的每个对象实现了同样的方法，处理对链中第一个对象发起的同一个请求。如果一个对象不知道如何处理请求，它就把请求传给下一个相应器(即successor)。\n\n15.3 Handler是上层抽象类，定义了一个方法---handleRequest，处理它知道如何处理的请求对象。ConcreteHandler1和ConcreteHandler2实现了handleRequest方法，来处理它们认识的请求对象。Handler也有一个指向另一个同类型实例的引用，即successor。当调用Handler实例的handleRequest消息时，如果这个实例不知道如何处理请求，它会用同样的消息把请求转发给successor。如果successor可以处理，就行了；否则，他就把请求传给下一个successor(如果有的话)。这个过程会一直进行下去，直到请求被传到链中的最后一个successor。\n\n15.4 在RPG游戏中使用责任链模式\n\n![RPG责任链模式](http://upload-images.jianshu.io/upload_images/1294131-39ffa722b6ea33c2..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\nAvatar、MetalArmor和CrystalShield是AttackHandler的子类。AttackHandler定义了一个方法---handleAttack:attack，该方法的默认行为是把攻击传给另一个AttackHandler的引用，即成员变量nextAttackHandler_。子类重载这个方法，对攻击提供实际的响应。如果AttackHandler不知道如何响应一个攻击，那么就使用[super handleAttack:attack]消息，把它转发给super，这样super中的默认实现就会把攻击沿着链传下去。\n\n> 代码清单 AttackHandler.h\n\t\n\t#import \"Attack.h\"\n\n\t@interface AttackHandler : NSObject\n\n\t{\n\t\t@private\n\t\tAttackHandler *nextAttackHandler_;\n\t}\n\n\t@property (nonatomic, strong) AttackHandler *nextAttackHandler;\n\n\t- (void)handleAttack:(Attack *)attack;\n\n\t@end\n\n> 代码清单 AttackHandler.m\n\t\n\t@implementation AttackHandler\n\n\t@synthesize nextAttackHandler = nextAttackHandler_;\n\n\t- (void)handleAttack:(Attack *)attack {\n\t\t[nextAttackHandler_ handleAttack:attack];\n\t}\n\n\t@end\n\t\n> 代码清单 MetalArmor.h\n\t\n\t@interface MetalArmor : AttackHandler\n\n\t// 重载的方法\n\t- (void)handleAttack:(Attack *)attack;\n\n\t@end\n\t\n> 代码清单 MetalArmor.m\n\t\n\t- (void)handleAttack:(Attack *)attack {\n\t\tif ([attack isKindOfClass:[SwordAttack class]]) {\n\t\t\t// 攻击没有通过这个盔甲\n\t\t\tNSLog(@\"No damage from a sword attack\");\n\t\t}\n\t\telse {\n\t\t\tNSLog(@\"I don't know this attack: %@\",[self class]);\n\t\t\t[super handleAttack:attack];\n\t\t}\n\t}\n\t\n> 代码清单 CrystalShield.m\n\t\n\t- (void)handleAttack:(Attack *)attack {\n\t\tif ([attack isKindOfClass:[MagicFireAttack class]]) {\n\t\t\t// 攻击没有通过这个盾牌\n\t\t\tNSLog(@\"No damage from a magic fire attack\");\n\t\t}\n\t\telse {\n\t\t\tNSLog(@\"I don't know this attack: %@\",[self class]);\n\t\t\t[super handleAttack:attack];\n\t\t}\n\t}\n\t\n> 代码清单 Avatar.m\n\t\n\t- (void)handleAttack:(Attack *)attack {\n\t\t// 当攻击达到这里时，我就被击中了\n\t\t// 实际损伤的点数取决于攻击的类型\n\t\tNSLog(@\"Oh! I'm hit with a %@\",[attack class]);\n\t}\n\t\n> 代码清单，客户端代码\n\n\t // 创建新的人物\n    AttackHandler *avatar = [[Avatar alloc] init];\n    \n    // 让它穿上金属盔甲\n    AttackHandler *metalArmoredAvatar = [[MetalArmor alloc] init];\n    [metalArmoredAvatar setNextAttackHandler:avatar];\n    \n    // 然后给金属盔甲中的人物添加一个水晶盾牌\n    CrystalShield *superAvatar = [[CrystalShield alloc] init];\n    [superAvatar setNextAttackHandler:metalArmoredAvatar];\n    \n    // ... 其他行动\n    \n    // 用剑去攻击人物\n    Attack *swordAttack = [[SwordAttack alloc] init];\n    [superAvatar handleAttack:swordAttack];\n    \n    // 然后用魔法火焰攻击人物\n    Attack *magicFireAttack = [[MagicFireAttack alloc] init];\n    [superAvatar handleAttack:magicFireAttack];\n    \n    // 现在用闪电进行新的攻击\n    LightningAttack *lightningAttack = [[LightningAttack alloc] init];\n    [superAvatar handleAttack:lightningAttack];\n    \n    // ... 进一步的行动\n\n\t\n\t// 客户端代码的输出\n\tI don't know this attack: CrystalShield\n\tNo damage from a sword attack\n\tNo damage from a magic fire\n\tI don't know this attack: CrystalShield\n\tI don't know this attack: MetalArmor\n\tOh! I'm hit with a LightningAttack\n\t\n\t\n金属盔甲为人物挡住了剑的攻击，因为有水晶盾牌，魔法火焰攻击也没有伤到人物。但是第三次的闪电攻击，盔甲和盾牌都不知道如何应付，最后，打出来消息：Oh! I'm hit with a LightningAttack，表示因闪电攻击而受到损伤。\n\n15.5 何时使用责任链模式\n\n1. 有多个对象可以处理请求，而处理程序只有在运行时才能确定\n2. 向一组对象发出请求，而不想显示指定处理请求的特定处理程序\n\n***\n\n### 算法封装\n\n##### 16. 模板方法\n\n16.1 模板方法模式：定义一个操作中算法的骨架，而将一些步骤延迟到子类中。模板方法使子类可以重定义算法的某些特定步骤而不改变该算法的结构。\n\n![模板方法](http://upload-images.jianshu.io/upload_images/1294131-c5d41ab275e75130..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n模板方法模式是面向对象软件设计中一种非常简单的设计模式，其基本思想是在抽象类的一个方法中定义“标准”算法。在这个方法中调用的基本操作应由子类重载予以实现。这个方法称为模板方法。因为方法定义的算法缺少一些特有的操作。\n\nAbstractClass 不完整地定义了一些方法与算法，留出一些操作未作定义。AbstractClass 调用的templateMethod 时，方法中未定义的空白部分，由 ConcreteClass重载 primitiveOperation1(或2)来填补\n\n说明: 钩子操作给出默认行为，子类可对其扩展。默认行为通常什么都不做。子类可以重载这个方法，为模板方法提供附加的操作。\n\n16.2 在Cocoa Touch框架中使用模板方法，\n\n利用模板方法制作三明治。包含基本步骤：准备面包、把面包放在盘子上、往面包上加肉、加调味料、上餐；可以定义一个叫 **make** 的模板方法，它调用上述哥哥步骤来制作真正的三明治。制作真正三明治的默认算法有些特定的操作没有实现，所以模板方法知识定义了制作三明治的一般方法。当具体三明治子类重载了三明治的行为之后，客户端仅用 **make** 消息就能制作真正的三明治了\n\n> 代码清单 AnySandwich.h \n\t\n\t@interface AnySandwich : NSObject\n\n\t- (void)make;\n\n\t// 制作三明治的步骤\n\t- (void)prepareBread;\n\t- (void)putBreadOnPlate;\n\t- (void)addMeat;\n\t- (void)addCondiments;\n\n\t// hook\n\t- (void)extraStep;\n\n\t- (void)serve;\n\n\t@end\n\n*** \n\n> 代码清单 AnySandwich.m\n\t\n\t- (void)make {\n\t\t[self prepareBread];\n\t\t[self putBreadOnPlate];\n\t\t[self addMeat];\n\t\t[self addCondiments];\n    \n\t\t// hook\n\t\t[self extraStep];\n    \n\t\t[self serve];\n\t}\n\n\t- (void)putBreadOnPlate {\n\t\t// 做任何三明治都要先把面包放在盘子上\n\t}\n\n\t// hook\n\t- (void)extraStep {\n    \n\t}\n\n\t- (void)serve {\n\t\t// 任何三明治做好了都要上餐\n\t}\n\n\t#pragma mark -\n\t#pragma mark - Details will be handled by subClasses\n\t- (void)prepareBread {\n\t\t// 要保证子类重载这个方法\n\t}\n\t- (void)addMeat {\n\t\t// 要保证子类重载这个方法\n\t}\n\t- (void)addCondiments {\n\t\t// 要保证子类重载这个方法\n\t}\n\t\n> 代码清单 ReubenSandwich.h\n\t\n\t@interface ReubenSandwich : AnySandwich\n\n\t- (void)prepareBread;\n\t- (void)addMeat;\n\t- (void)addCondiments;\n\n\t// hook\n\t- (void)extraStep;\n\n\t// 鲁宾三明治的特有操作\n\t- (void)cutRyeBread;\n\t- (void)addCornBeef;\n\t- (void)addSauerkraut;\n\t- (void)addThousandIslandDressing;\n\t- (void)addSwissCheese;\n\n\t- (void)grillit;\n\n\t@end\n\t\n> 代码清单 ReubenSandwich.m\n\t\n\t- (void)prepareBread {\n\t\t[self cutRyeBread];\n\t}\n\t- (void)addMeat {\n\t\t[self addCornBeef];\n\t}\n\t- (void)addCondiments {\n\t\t[self addSauerkraut];\n\t\t[self addThousandIslandDressing];\n\t\t[self addSwissCheese];\n\t}\n\n\t// hook\n\t- (void)extraStep {\n\t\t[self grillit];\n\t}\n\n\t#pragma mark -\n\t#pragma mark - ReubenSandwich Specific methods\n\t- (void)cutRyeBread {\n\t\t// 鲁宾三明治需要两片黑麦面包\n\t}\n\t- (void)addCornBeef {\n\t\t// ...... 加大量腌牛肉\n\t}\n\t- (void)addSauerkraut {\n\t\t// ...... 还有德国酸菜\n\t}\n\t- (void)addThousandIslandDressing {\n\t\t// ...... 别忘了千岛酱\n\t}\n\t- (void)addSwissCheese {\n\t\t// ...... 还有上等瑞士奶酪\n\t}\n\n\t- (void)grillit {\n\t\t// 最后要把它烤一下\n\t}\n\nReubenSandwich是AnySandwich的子类。制作鲁宾三明治有其特有的步骤和配料。鲁宾三明治的面包需要黑麦面包，肉需要腌牛肉，还需要德国酸菜，调味料需要千岛酱和瑞士奶酪。虽然奶酪不能算调味料，但这么做可以简化制作三明治的一般步骤，因为不是所有三明治都有奶酪。\n\n> 代码清单 Humburger.h\n\t\n\t@interface Humburger : AnySandwich\n\n\t- (void)prepareBread;\n\t- (void)addMeat;\n\t- (void)addCondiments;\n\n\t// 汉堡包的特有方法\n\t- (void)getBurgerBun;\n\t- (void)addKetchup;\n\t- (void)addMustard;\n\t- (void)addBeefPatty;\n\t- (void)addCheese;\n\t- (void)addPickles;\n\n\t@end\n\n> 代码清单 Humburger.m\n\t\n\t- (void)prepareBread {\n\t\t[self getBurgerBun];\n\t}\n\t- (void)addMeat {\n\t\t[self addBeefPatty];\n\t}\n\t- (void)addCondiments {\n\t\t[self addKetchup];\n\t\t[self addMustard];\n\t\t[self addPickles];\n\t}\n\n\t#pragma mark -\n\t#pragma mark - Humburger Specific Methods\n\t- (void)getBurgerBun {\n\t\t// 汉堡包需要小圆面包\n\t}\n\t- (void)addKetchup {\n\t\t// 先要放番茄酱，才能加其他材料\n\t}\n\t- (void)addMustard {\n\t\t// 然后加点儿芥末酱\n\t}\n\t- (void)addBeefPatty {\n\t\t// 汉堡包的主料是一片牛肉饼\n\t}\n\t- (void)addCheese {\n\t\t// 假定汉堡包都有奶酪\n\t}\n\t- (void)addPickles {\n\t\t// 最后加点儿腌黄瓜\n\t}\n\t\nHumburger也是AnySandwich的子类，它也有自己的制作细节。汉堡包的面包需要小圆面包，肉需要牛肉饼，调味料需要番茄酱、芥末酱、腌黄瓜和奶酪。\n\n16.2 何时实用模板方法\n\n1. 需要一次性实现算法的不变部分，并将可变的行为留给子类来实现\n2. 子类的共同行为应该被提取出来放到公共类中，以避免代码重复。现有代码的差别应该被分离为新的操作。然后用一个调用这些新操作的模板方法来替换这些不同的代码\n3. 需要控制子类的扩展。可以定义一个在特定点调用 “钩子”(hook)操作的模板方法，子类可以通过对钩子操作的实现在这些点扩展功能。\n\n##### 17. 策略\n\n17.1 策略模式：定义一些列算法，把它们一个个封装起来，并且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化\n\n![策略模式](http://upload-images.jianshu.io/upload_images/1294131-8a0cd6a0bbd2d801..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n策略模式中的一个关键角色是策略类，它为所有支持的或相关的算法申明了一个共同接口。另外，还有使用策略接口来实现相关算法的具体策略类。场景(context)类的对象配置有一个具体策略对象的实例，场景对象使用策略接口调用由具体策略类定义的算法。\n\n17.2 何时使用策略模式\n\n1. 一个类在其操作中使用多个条件语句来定义许多行为。我们可以把相关的条件分之移到它们自己的策略类中\n2. 需要算法的各种变体\n3. 需要避免把复杂的、与算法相关的数据结构暴露给客户端\n\n***\n\n##### 18. 命令\n\n18.1 命令模式：将请求封装为一个对象，从而可用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。\n\n![命令模式](http://upload-images.jianshu.io/upload_images/1294131-842cdd16282bfe29..png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n18.2 何时使用命令模式\n\n1. 想让应用程序支持撤销与恢复\n2. 想用对象参数化一个动作以执行操作，并用不同命令对象来代替回调函数\n3. 想要在不同时刻对请求进行指定、排列和执行\n4. 想记录修改日志，这样在系统故障时，这些修改可在后来重做一遍\n5. 想让系统支持事务，事务封装了对数据的一些列修改。事务可以建模为命令对象"
        }
    ]
}
