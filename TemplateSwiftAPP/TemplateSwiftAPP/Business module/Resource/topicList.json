{
    "status": 200,
    "message": "请求成功",
    "data": [
             {
             "id": "DE2B16AD-508E-4544-A0F0-23D51535F49A",
             "categoryId": 2,
             "userID": "9B7D73E9-9F92-4365-BC1D-7C7CBC4FF59F",
             "likeNum": 1,
             "author": "turkeyaa",
             "isGood": 0,
             "title": "运行时系统",
             "viewNum": 10,
             "createTime": 1531626942,
             "collectNum": 0,
             "replyNum": 0,
             "content": "---\nlayout: post\ntitle: iOS运行时\ncategories: [技术]\ntags: [Objective-C]\ndescription:\n---\n\n> Objective-C 拥有相当多的动态特性，这些特性在运行程序时发挥作用，而不是在编译或者链接代码时发挥作用。Objective-C运行时系统实现了这些特性，而这些功能为Objective-C语言提供了非常多的强大功能和灵活性。\n\n* 运行时系统\n* 运行时系统的结构\n* 使用运行时系统API\n\n***\n\n## 运行时系统\n\n### 1.1 动态功能\n\n##### 在运行时，Objective-C语言会执行其他语言在程序编译或链接时会执行的许多常规操作，如确定类型和方法解析。这些操作还可以提供API，使你编写的程序能够执额外的运行时操作，如对象内省和以动态方式创建和加载代码。Objective-C运行时系统的结构和实现方式生成了这些动态特性\n\n### 1.2 对象消息\n\n##### 在OOP术语中，消息传递是指一种在对象之间发送和接受消息的通信模式。用于调用类和类实例的方法。\n\n##### 对象消息传递是以动态方式实现的特性，接收器的类型和相应的调用方法是在运行时决定的。\n\n* 消息：向对象/类发送的名称(选择器)和一些列参数\n* 方法：Objective-C中的类或实例方法，其申明中含有名称、输入参数、返回值和方法签名(即输入参数和返回值的数据类型)\n* 方法绑定：接收向指定接收器发送的消息并寻找和执行适当方法的处理过程。Objective-C运行时系统在调用方法时，会以动态绑定方式处理消息。\n\n### 1.3 选择器\n\n##### 选择器是一种文本字符串，用于指明调用对象或类中的哪些方法。选择器是一种分为多个段的文本字符串，每个段以冒号结尾并且后跟参数，例如：\n\t\n\t分段1：分段2：分段3：\n\t\n##### 这个选择器中有3个分段，每个分段都带一个冒号，因而表明了相应的消息具有3个输入参数。\n\n\t// 选择器示例\n\tdescription\n\tdescription:\n\tsumAddend1:addend2:\n\tsumAddend1::\n\t\n##### 消息的选择器直接与一个或多个类/实例方法声明对应。下面展示一个类接口，该接口中含有一个实例方法声明\n\n\t@interface Calculator : NSObject\n\t- (int)sumAddend1:(NSInteger)a1 addend2:(NSInteger)a2;\n\t@end\n   \t\n##### Calculator 类实例方法的选择器为sumAddend1:addend2:。如果初始化一个Calculator对象并将其分配给一个名为myCalculator的变量，那么调用该实例方法就需要使用接收器对象(myCalculator)后跟带输入参数的选择器，例如：\n\t[myCalculator sumAddend1:25 addend2:10];\n\t\n##### 当源代码被编译时，编译器(运行时系统的组成部分)会创建数据结构和函数调用语句，使用它们以动态方式将接收器(类/对象)和消息选择器与方法的实现代码对应起来。在执行程序时，运行时库(运行时系统的另一个组成部分)利用这些消息找到并调用适当的方法。\n\n##### 选择器类型(SEL)是一种特殊的Objective-C数据类型，是用于在编译源代码时替换选择器值的唯一标识符。所有具有相同选择器值的方法都拥有相同的SEL标识符。可使用关键字@selector创建SEL类型的变量，例如：\n\tSEL myMethod = @selector(myMethod:);\n\t\n##### 如果在运行时创建选择器变量，可以这样写：\n\tSEL myMethod = NSSelectorFromString(@\"myMethod:\");\n\t[obj performSelector: myMethod withObject:[NSNumber numberWithInteger:40]];\n\t\n### 1.4 方法签名\n\n##### 方法签名(method signature)定义了方法输入参数的数据类型和方法的返回值(如果存在)。编译器会将 [接收器 消息] 形式的对象消息，转换为声明中含有方法签名的(ANSI)C函数调用语句。因此，为了生成正确的对象消息传递代码，编译器需要获得选择器值和方法签名。编译器可以从对象消息表达式中轻松提取选择器，但是它如何获取方法签名呢?消息可能含有输入参数，而且因为接收器和相应的方法是在程序运行时确定的，所以编译器无法知道使用怎样的数据类型才能与要调用的方法对应起来。为了确定正确的方法签名，编译器会根据已解析的方法声明进行猜测。如果它找不到方法签名，或者它从方法声明获得的方法签名与运行时实际执行的方法不匹配，就会出现方法签名不匹配的情况，会导致从编译器警告道运行时错误的各种问题。\n\n### 1.5 使用对象消息\n\n##### 创建Calculator类，继承NSObject类，添加两个实例方法：sumAddend1:addend2: 和 sumAddend1::。\n\n\t@interface Calculator : NSObject\n\n\t- (NSNumber *)sumAddend1:(NSNumber *)a1 addend2:(NSNumber *)a2;\n\t- (NSNumber *)sumAddend1:(NSNumber *)a1 :(NSNumber *)a2;\n\n\t@end\n\n##### 我们可以这样调用该方法\n\n\tCalculator *obj = [[Calculator alloc] init];\n\tNSNumber *rs1 = [obj sumAddend1:@(10) addend2:@(15)];\n\tNSNumber *rs2 = [obj sumAddend1:@(10) :@(25)];\n\t\n##### 或者通过运行时方式调用该方法\n\n\tSEL myMethod = NSSelectorFromString(@\"sumAddend1::\");\n\tNSNumber *rs3 = [obj performSelector:myMethod withObject:@(10) withObject:@(35)];\n\t\n### 1.5 动态类型\n\n##### 运行时系统通过动态类型(dynamic typing)功能，可以在运行程序时决定对象的类型，因而可以使运行时因素能够在程序中指定使用哪种类型对象。在事先无法知道为变量分配那种类型的对象的情况下(如向方法传送参数)，这就特别有用。既支持静态类型也支持动态类型。当使用静态方式设置变量的类型时，变量的类型就由它的声明决定。\n\t// 变量 myAtom 声明为指向Atom类实例的指针\n\tAtom *myAtom;\n\t\n\t// myAtom 声明为id数据类型，运行时检查myAtom类型\n\tid *myAtom;\n\t\n##### 使用动态类型可以简化类接口，无须为每个可能出现的输入参数类型编写不同的方法声明。动态类型还可以提供非常大的灵活性，可以在执行程序的过程中改进程序使用的数据类型，并在不重新编译和重新部署的情况下引入新的数据类型。\n\n### 1.6 动态绑定\n\n##### 动态绑定是指在运行时(而不是编译时)将消息与方法对应起来的处理过程。因为许多接收器对象会实现相同的方法，调用方法的方式会动态变化。因此动态绑定实现了 OOP 的多态性。使用动态绑定可以在不影响既有代码的情况下，将新对象和代码连接或添加到系统中，从而降低对象之间的耦合度。通过消除用于处理多选情景(通常由条件语句实现)的条件逻辑，动态绑定还能够降低程序的复杂度。如图：\n\n![动态绑定]({{ turkeyaa.github.io }}/assets/2016/Runtime/dynamicBind.png)\n\n\tid atom = [[Hydrogen alloc] initWithNeutrons:1];\n\t[atom logInfo];\n\t\n##### 在执行这段代码时，运行时系统会确定变量atom的实际类型(通过动态绑定)，然后使用消息选择器(logInfo)将该消息与接收器(atom对象)的实例方法对应起来。在本例中，变量atom的类型被设置为Hydrogen *，因此运行时系统会搜索Hydrogen类中的实例方法logInfo。如果找不到，那么它就会在Hydrogen类的父类中寻找相应的实例方法。运行时系统会一直在类层次结构中寻找该实例方法，直到找到为止。否则方法被转发甚至异常。\n\n### 1.7 动态方法决议\n\n##### 使用动态方法决议能够以动态方式实现方法。使用Objective-C中的@dynamic指令，可以告知编译器与属性关联的方法会议动态方式实现。NSObject类中含有 ``` resolveInstanceMethod: ``` 和 ``` resolveClassMethod: ``` 方法，它们能够以动态方式分别为指定的实例和类方法选择器提供实现代码。你可以重写这些方法，以动态方式实现实例/类方法。下面例子：\n\n\t#import <objc/runtime.h>\n\t+ (BOOL)resolveInstanceMethod:(SEL)sel {\n\t\tNSString *method = NSStringFromSelector(sel);\n\t\tNSLog(@\"Selector name = %@\",method);\n\t\tif ([method hasPrefix:@\"absoluteValue\"]) {\n\t\t\tclass_addMethod([self class], sel, (IMP)absoluteValue, \"@@:@\");\n\t\t\tNSLog(@\"Dynamically instance method %@ to class %@\",method,[self class]);\n\t\t\treturn YES;\n\t\t}\n\t\treturn [super resolveInstanceMethod:sel];\n\t}\n\t\n\t// 添加该方法\n\tid absoluteValue(id self, SEL _cmd, id value) {\n\t\tNSInteger intValue = [value integerValue];\n\t\tNSLog(@\"Self = %@, value = %@\",self,value);\n\t\tif (intValue < 0) {\n\t\t\treturn [NSNumber numberWithInteger:(intValue * -1)];\n\t\t}\n\t\telse {\n\t\t\treturn [NSNumber numberWithInteger:intValue+1];\n\t\t}\n\t}\n\t\n\t// 客户端调用\n\tCalculator *obj = [[Calculator alloc] init];\n    \n    SEL selector = NSSelectorFromString(@\"absoluteValue:\");\n    id sum = [obj performSelector:selector withObject:[NSNumber numberWithInteger:40]];\n    NSLog(@\"sum = %@\",sum);\n    \n    // 结果 sum = 41\n    \n##### 这段代码以动态方式为新建方法创建了一个选择器，然后使用该选择器调用了一个实例方法。通过动态方法决议可以在运行时添加和调用这个方法，并获得返回值。\n\n### 1.8 内省\n\n##### Foundation框架中NSObject类的API含有非常多用于执行对象内省的方法。因为Objective-C的运行时行为与它的编译和链接时行为差异非常大，所以对象内省就成为了一种关键功能，使用它可以避免运行时错误。使用这些方法能够以动态方式在程序运行时查询下列信息：\n\n* 与方法有关的信息；\n* 测试对象的继承性、行为和一致性的信息。\n\n##### 测试接收器是Calculator类的实例还是Calculator类的子类的实例\n\tBOOL isCalculator = [obj isKindOfClass:[Calculator class]];\n\t\n##### 检查某个对象是否会对选择器做出回应\n\tBOOL responds = [obj respondsToSelector:@selector(sumAddend1::)];\n\t\n##### 检查对象是否遵守指定协议\n\tBOOL conforms = [obj conformsToProtocol:@protocol(MyProtocol)];\n\t\n##### 为选择器提取方法签名\n\tNSMethodSignature *signature = [obj methodSignatureForSelector:@selector(sumAddend1::)];\n\n***\n\n## 运行时系统的结构\n\n> Objective-C的运行时系统由两个主要部分构成：编译器和运行时系统库。\n\n### 2.1 编译器\n\n##### 编译器会接收Objective-C源文件并进行处理(该处理过程由词法分析、语法分析、代码生成和优化、汇编以及链接操作等阶段构成)，生成构成可执行程序的二进制文件。编译器的作用是接收输入的源代码，生成使用了运行时系统库的代码，从而得到合法的、可执行的Objective-C程序。\n\n### 2.2 运行时系统库\n\n##### 就像C语言标准函数库会为C语言程序提供标准API和实现代码一样，运行时系统库也会为Objective-C的面向对象特性提供标准API和实现代码。这种库与所有Objective-C程序链接。\n\n##### 运行时系统由下列部分组成：\n1. 类元素(接口、实现代码、协议、分类、属性、实例变量)\n2. 类实例(对象)\n3. 对象消息传递(包括动态类型和动态绑定)\n4. 动态方法决议\n5. 动态加载\n6. 对象内省\n\n##### 运行时系统的公用API是在头文件runtime.h中声明的。可以从 [http://opensource.apple.com](http://opensource.apple.com)获取苹果公司提供的运行时系统库。随着Objective-C语言的不断发展，将它与各种设计元素与系统服务一同使用，可以获得更好的性能和可扩展性。\n\n##### 使用运行时系统库API创建类\n\t#import <objc/runtime.h>\n\t#import <objc/message.h>\n\t\n\tNSString *greeting2(id self, SEL _cmd) {\n\t\treturn [NSString stringWithFormat:@\"Hello, World!\"];\n\t}\n\t\n\t// 以动态的方式创建一个类\n\tClass dynaClass = objc_allocateClassPair([NSObject class], \"DynaClass\", 0);\n\t// 以动态方法添加一个方法，使用已有的方法 (description)获取特性\n\tMethod description = class_getInstanceMethod([NSObject class], @selector(description));\n    const char *type = method_getTypeEncoding(description);\n    class_addMethod(dynaClass, @selector(greeting2), (IMP)greeting2, type);\n    \n\t// 注册这个类\n\tobjc_registerClassPair(dynaClass);\n    \n\t// 使用该类创建一个实例并向其发送一条消息\n\tid dynaObj = [[dynaClass alloc] init];\n    \n\tSEL selector = NSSelectorFromString(@\"greeting2\");\n\tNSString *rs = [dynaObj performSelector:selector];\n\tNSLog(@\"rs = %@\",rs);\n\n\t// 结果为： rs = Hello, World!\n\n##### 首先导入头文件才能将运行时系统库中的消息传递API。它创建了一个类对(类及其元类)，向这个类对中添加了一个指向先前创建的greeting2()函数的方法，然后在运行时注册该类对，从而使你编写的程序能够创建这个类的实例。方法签名是通过使用拥有相同签名的方法(NSObject类的description方法)获取的。再然后创建了一个类实例并向其发送了一条消息，然后将获得的结果显示到输出窗格中。\n\n##### \t运行时系统库含有可用于访问下列信息的函数(括号中为函数名)\n* 对象的类定义(objc_getClass)\n* 类的父类(class_getSuperClass)\n* 对象的元类定义(objc_getMetaClass)\n* 类的名称(class_getName)\n* 类的版本信息(class_getVersion)\n* 以字节为单位的类尺寸(class_getInstanceSize)\n* 类的实例变量列表(class_copyIvarList)\n* 类的方法列表(class_copyMethodList)\n* 类的协议列表(class_copyProtocolList)\n* 类的属性列表(class_copyPropertyList)\n\n##### 总而言之，运行时系统库数据类型和函数为运行时系统库提供了实现各种Objective-C特性(如对象消息传递)所必需的数据类型和函数。当程序向对象发送消息时，运行时系统会通过自定义代码中的类方法缓存和虚函数表，查找类的实例方法。为了找到相应的方法，运行时系统会搜索整个类层次结构，找到该方法后，它就会执行该方法的实现代码。\n\n![运行时系统中的消息传递操作]({{ turkeyaa.github.io }}/assets/2016/Runtime/isaPoint.png)\n\n##### 运行时系统库中的方法数据类型\n\tstruct objc_method\n\t{\n\t\tSEL method_name;\n\t\tchar *method_types;\n\t\tIMP method_imp;\n\t};\n\ttypedef objc_method Method;\n\t\n##### 运行时系统库的方法查询逻辑\n\n![运行时系统库的方法查询逻辑]({{ turkeyaa.github.io }}/assets/2016/Runtime/searchIMP.png)\n\t\n***\n\n## 使用运行时系统API\n\n##### TODO"
             },
             {
             "id": "9810CCA5-155A-4624-BA20-17F71A0C2F97",
             "categoryId": 1,
             "userID": "9B7D73E9-9F92-4365-BC1D-7C7CBC4FF59F",
             "likeNum": 1,
             "author": "turkeyaa",
             "isGood": 0,
             "title": "Objective-C 框架搭建",
             "viewNum": 51,
             "createTime": 1531571106,
             "collectNum": 0,
             "replyNum": 3,
             "content": "` 本教程旨在让我们更加快速、高效的开发移动app `\n\n[这是Demo](https://github.com/turkeyaa/TemplateCocoa)\n\n1. 目录结构\n2. 接口封装\n3. 界面封装\n4. 模型封装\n5. 对象组合\n6. 工具类\n\n\n#### 1. 目录结构图\n![]({{ turkeyaa.github.io }}/assets/2015/product_structure.png)\n\n##### 说明\n\n* APIs：包含所有的接口调用，每个接口都包装成一个单独的类。处理数据的解析、回调、传值、统计分析、错误日志、错误码\n* Common：封装界面相关的类，比如BaseVC、BaseTC、BaseView、BaseTCell...等\n* Image：本地图片资源\n* Macro：定义常量、枚举、block...等\n* Model：定义模型\n* Resource：本地 json 数据，模拟本地接口\n* Service：单例类、工具类...等\n* Vendors：自定义第三方工具插件\n* VCs：新功能模块开发\n* Images.xcassets：切图资源\n* PrefixHeader.pch：编译预引用头文件\n* Pods：第三方库\n\n***\n\n#### 2. 接口封装\n\n> 一般的我们会使用第三方插件(AFNetworking...)来处理网络请求，每个请求都是通过AFN来调用，这样不好是因为开发和维护都需要很多的工作量。而有写经验的开发者会考虑在基类中实现AFN接口，通过继承的方式来处理网络请求，这样就很好了。下面介绍如何打造自己的网络库。\n\n#### 一般的网络请求方法步骤：\n\n\t// 1. 创建url\n\tNSString *urlStr = @\"http://192.169.1.88/loging?account=turkey&password=123456\";\n\tNSURL *url = [NSURL URLWithString:urlStr];\n\t\n\t// 2. 创建请求\n\tNSURLRequest *request = [NSURLRequest requestWithURL:url];\n\t\n    // 3. 创建会话（这里使用了一个全局会话）\n    NSURLSession *session = [NSURLSession sharedSession];\n    \n    // 4. 通过会话创建任务\n    NSURLSessionDataTask *dataTask = [session dataTaskWithRequest:request \n            completionHandler:^(NSData *data, NSURLResponse *response, NSError *error) {\n        if (!error) {\n            NSString *dataStr = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];\n            NSLog(@\"%@\",dataStr);\n        }else{\n            NSLog(@\"error is :%@\",error.localizedDescription);\n        }\n    }];\n    \n    // 5. 每一个任务默认都是挂起的，需要调用 resume 方法启动任务\n    [dataTask resume];\n    \n#### 这些方法是通用的，不同的只是参数、请求方式(GET/POST/PUT...)、接口路径、返回的数据。那我们是不是可以把不同的参数通过多态(重写父类的方法)来实现。而请求数据完成，通过block、代理或重载来处理不同的结果。这里的结果一般的是json数据，同时就可以把json转换成model传递给相应的控制器对象。你会发现我们的请求过程会特别的简单、方便。流程图：\n\n![]({{ turkeyaa.github.io }}/assets/2015/MVC.png)\n\n#### 在ViewController中，登录接口就是这样：\n\n\t// 在 LoginVC.m 中实现登录\n\tLogin_Post *loginApi = [[Login_Post alloc] initWithAccount:account password:password];\n\t[loginApi call];\n\t\n\tif (loginApi.code == RestApi_OK) {\n\t\t// 登录成功，赋值，其他处理....\n\t\tUserInfo *userInfo = loginApi.userInfo;\n\t\t\n\t}\n\telse {\n\t\t// 登录失败\n\t\t[self showErrorMessage:loginApi.errorMessage];\n\t}\n\t\n#### 如何实现？\n\n1. 定义RestApi，一个抽象类。包含：初始化、执行、取消、结果处理、参数...等方法。一些是子类必须要实现的方法(参数、结果处理)\n2. 定义BaseRestApi，继承RestApi。定义错误码和结果处理方法\n3. 定义Login_Post，继承BaseRestApi。定义初始化方法、请求参数、处理结果方法\n\n#### 在RestApi，中实现网络请求、回调，也可以处理一些统计分析、异常等处理。在BaseRestApi中会有相应的错误码，是否成功，提示客户。在LoginApi中得到回调，并解析，传递给相应的控制器。\n\n\t// 1. 定义一个枚举，请求方式\n\ttypedef NS_ENUM(NSInteger, HttpMethods) {\n    \tHttpMethods_Get = 1,\n\t\tHttpMethods_Post = 2,\n\t\tHttpMethods_Delete = 3,\n\t\tHttpMethods_Put = 4,\n\t};\n\t\n\t// 2. 初始化方法\n\t- (id)initWithURL:(NSString *)url httpMethod:(HttpMethods)httpMethod;\n\t\n\t// 3. 执行和取消\n\t- (void)call:(BOOL)async;\n\t- (void)cancel;\n\n\t// 3. 参数：Get、Post方式，\n\t- (NSData *)requestData;                // Post\n\t- (NSDictionary *)queryParameters;      // Get\n\n\t// 4. 回调，需要子类重写\n\t- (void)onSuccessed;\n\t- (void)onFailed;\n\t- (void)onCancelled;\n\t- (void)onTimeout;\n\t- (void)onError:(NSError *)error;\n\n#### 重点是 call：方法\n\n\t// 1. 数据请求必须在异步线程中\n\tif ([NSThread isMainThread] && !async) {\n        [self raiseException:@\"主线程不允许同步调用\"];\n        return;\n    }\n    \n    // 2. 初始化request\n    NSMutableURLRequest *request = [[NSMutableURLRequest alloc] init];\n    \n    // 3. 在GET请求中我的接口是：http://192.169.1.88/loging?account=turkey&password=123456\"。而POST请求接口：http://192.169.1.88/loging，参数方式不同。\n    if (_httpMethod == HttpMethods_Get) {\n        \n        NSMutableString *strUrl = [[NSMutableString alloc] initWithString:_url];\n        \n        @try {\n            NSDictionary *params = [self queryGetParameters];\n            if (params) {\n                \n                // Get 参数\n                NSArray *keys = params.allKeys;\n                \n                for (int i = 0; i< keys.count; i++) {\n                    NSString* key = [keys objectAtIndex:i];\n                    NSString* value = [params valueForKey:key];\n                    \n                    if (i == 0) {\n                        [strUrl appendString:@\"?\"];\n                    } else {\n                        [strUrl appendString:@\"&\"];\n                    }\n                    [strUrl appendString:key];\n                    [strUrl appendString:@\"=\"];\n                    [strUrl appendString:[NSString stringWithFormat:@\"%@\", value]];\n                }\n            }\n            \n            [request setURL:[NSURL URLWithString:strUrl]];\n            [request setHTTPMethod:@\"GET\"];\n            [request setTimeoutInterval:timeout];\n            \n        } @catch (NSException *exception) {\n            \n        } @finally {\n            \n        }\n    }\n    \n    else if (_httpMethod == HttpMethods_Post) {\n        [request setURL:[NSURL URLWithString:_url]];\n        [request setHTTPMethod:@\"POST\"];\n        [request setValue:@\"application/json\" forHTTPHeaderField:@\"Content-Type\"];\n        NSData *postData = [self queryPostData];\n        [request setHTTPBody:postData];\n    }\n    else {\n        NSAssert(NO, @\"目前只支持 GET、POST 请求方式\");\n    }\n    \n    NSLog(@\"url = %@\",_url);\n    \n    __weak RestApi *weakSelf = self;\n    \n    // 4. 这里通过条件来实现线程同步\n    NSCondition *condition = [[NSCondition alloc] init];\n    \n    NSURLSession *session = [NSURLSession sharedSession];\n    \n    _task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) {\n        \n        if (error) {\n            \n            [weakSelf doFailure:error];\n        }\n        else {\n            [weakSelf doSuccess:data];\n        }\n        \n        [condition lock];\n        [condition signal];\n        [condition unlock];\n    }];\n    \n    // 5. 开始请求\n    [_task resume];\n    \n    if (condition) {\n        [condition lock];\n        [condition wait];\n        [condition unlock];\n    }\n\n#### 在BaseRestApi中，需要重写queryPostData:\n\t\n\tid requestData = [self prepareRequestData];\n    \n    if ([requestData isKindOfClass:NSData.class]) {\n        return requestData;\n    }\n    if ([requestData isKindOfClass:NSDictionary.class]) {\n        NSMutableDictionary* dict = [NSMutableDictionary dictionaryWithDictionary:requestData];\n        NSData * jsondata=[NSJSONSerialization dataWithJSONObject:dict options:NSJSONWritingPrettyPrinted error:nil];\n        return jsondata;\n    }\n    if ([requestData isKindOfClass:NSArray.class]) {\n        \n        NSMutableArray *array = [NSMutableArray arrayWithArray:requestData];\n        NSData *jsondata = [NSJSONSerialization dataWithJSONObject:array options:NSJSONWritingPrettyPrinted error:nil];\n        return jsondata;\n    }\n    if ([requestData isKindOfClass:NSString.class]) {\n        return [((NSString*)requestData) dataUsingEncoding:NSUTF8StringEncoding];\n    }\n    return nil;\n    \n#### 还有 doSuccess: 方法\n\n\t// 1. 调用的哪个接口，返回的json数据，方便调试用\n\tNSLog(@\"RestApi :[%@]\",self.class);\n\tNSLog(@\"RestApi Response:[%@]\",[[NSString alloc] initWithData:responseObject encoding:NSUTF8StringEncoding]);\n    \n    // 2. 解析数据\n    @try {\n        NSError *error;\n        NSDictionary *json = [NSJSONSerialization JSONObjectWithData:responseObject options:NSJSONReadingAllowFragments error:&error];\n        self.code = [json[@\"status\"] integerValue];\n        self.message = json[@\"message\"];\n        \n        if (self.code == RestApi_OK && [self parseResponseJson:json]) {\n            [self onSuccessed];\n        }\n        else {\n            if (self.code == RestApi_OK) {\n                \n                [self onSuccessed];\n            }\n            else {\n                [self onFailed];\n            }\n        }\n        \n    } @catch (NSException *exception) {\n        [self onError:nil];\n    } @finally {\n        \n    }\n    \n#### 在 Login_Post中，重写parseResponseJson：、prepareRequestData方法(如果的GET请求：queryParameters)\n\t\n\t// 解析\n\t- (BOOL)parseResponseJson:(NSDictionary *)json {\n    \n    \tNSDictionary *data = json[@\"data\"];\n\t\tif (data) {\n\t\t\t// 这里处理登录成功返回的JSON数据, 这里使用YYModel库\n\t\t\tself.userInfo = [UserModel yy_modelWithJSON:data];\n\t\t}\n    \n\t\treturn self.userInfo && self.userInfo.user_id.length > 0;\n\t}\n\t\n\t// POST 请求\n\t- (id)prepareRequestData {\n\t\treturn @{\n             @\"user_account\":_account,\n             @\"user_pwd\":[URLUtil base64Encode:_password]\n\t\t};\n\t}\n\t\n\t// GET 请求是这样\n\t- (NSDictionary *)queryParameters {\n\t\treturn @{\n             @\"email\":_email\n             };\n\t}\n\n\n***\n\n#### 3. 界面封装\n\n#### 重点介绍**UIViewController**和**UITableViewCell**的封装\n\n#### UIViewController的继承关系，设计如下图：\n\n![BaseVC继承关系图]({{ turkeyaa.github.io }}/assets/2017/BaseLoadTC.png)\n\n#### 在BaseVC.h中，定义了一些属性和方法，包括：是否显示导航条、左标题、右标题、左图标、右图标、左条目事件、右条目事件、HUD的显示和隐藏。基本上满足了对控制器对象的基本的交互封装。\n\n#### 在BaseTC中，这是一个带有UITableView的视图控制器。包括：一个NSMutableArray类型的数据源和UITableView类型的表视图对象。\n\n#### 在BaseLoadTC中，这是一个带有下拉刷新、加载更多和表视图的视图控制器对象。\n\n#### 在我们的视图控制器中，就可以这样写：\n\n\t// 显示标题\n\tself.leftTitle = @\"登录\";\n\tself.rightTitle = @\"注册\";\n\t\n\t// 或者显示图标\n\tself.leftImage = [UIImage imageNamed:@\"app_icon\"];\n\tself.rightImage = [UIImage imageNamed:@\"app_icon\"];\n\t\n\t// 显示HUD\n\t[self showLoadingHUD];\n\t// 自定义HUD\n\t[self showLoadingHUD:@\"正在登录中...\"];\n\t// 隐藏HUD\n\t[self hideLoadingHUD];\n\t// 成功、失败、错误...等\n\t[self showSuccessMessage:@\"加载成功\"];\n\t[self showErrorMessage:@\"加载失败\"];\n\t[self showInfoMessage:@\"其他失败\"];\n\n#### BaseTCell类设计如下：\n\n![BaseTCell继承关系]({{ turkeyaa.github.io }}/assets/2017/BaseTCell.png)\n\n#### 通过 **tcell:reuse:** 方法来初始化UITableViewCell对象，支持 **click** 监听点击事件、**showIndicator** 是否显示右边的箭头、重写 **classCellHeight** 重写子类的高度、重写 **setupSubViews** 自定义子类界面。\n\n#### 然后我们的表视图数据源方法中 **tableView: cellForRowAtIndexPath:** ，初始化表视图就是这样：\n\n\t- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath {\n    \n\t\tMainCell *cell = [MainCell tcell:self.tableView reuse:YES];\n\t\tMainInfo *info = self.dataSource[indexPath.row];\n\t\tcell.mainInfo = info;\n\t\tcell.showIndicator = YES;\t\t// 默认为YES\n    \n\t\treturn cell;\n\t}\n\t\n#### 你也可以自定义UITableViewCell的高度：\n\n\t- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath {\n\t\treturn [MainCell classCellHeight];\n\t}\n\t\n***\t\n\n#### 4. 模型封装\n\n#### 对象模型对象，最基本的需要满足下面的功能：\n1. JSON和Model的相互转化\n2. 编码和解码\n3. 对象的深复制\n\n#### 一般的我们使用**MJExtension**来处理模型转化，基本上可以项目中的各种需求。如果让你自己来实现这些功能，该如何来设计？\n\n#### 定义JSONModel类，继承NSObject类。实现NSCopying,NSCoding,NSMutableCopying三个协议。支持编码和解码功能，两个类方法，支持JSON和Model的相互转化。\n\n> 代码清单 JSONModel.h\n\t\n\t@interface JSONModel : NSObject <NSCopying,NSCoding,NSMutableCopying>\n\n\t+ (id)jsonModelWithDictionary:(NSDictionary *)jsonDict;\n\t+ (NSDictionary *)jsonModelWithModel:(JSONModel *)model;\n\n\t@end\n\t\n> 代码清单 JSONModel.m\n\t\n\t// 基于运行时特性，动态获取类的属性\n\t#import \"NSObject+Property.h\"\n\t\n\t- (id)initWithDictionary:(NSDictionary *)jsonDict {\n\t\tif (self = [super init]) {\n\t\t\t[self setValuesForKeysWithDictionary:jsonDict];\n\t\t}\n\t\treturn self;\n\t}\n\n\t+ (id)jsonModelWithDictionary:(NSDictionary *)jsonDict {\n\t\tJSONModel *model = [[self alloc] initWithDictionary:jsonDict];\n\t\treturn model;\n\t}\n\n\t+ (NSDictionary *)jsonModelWithModel:(JSONModel *)model {\n    \n\t\tNSMutableDictionary *dict = [[NSMutableDictionary alloc] init];\n    \n\t\tNSArray *properNames = [model getPropertyList];\n    \n\t\tfor (NSString *key in properNames) {\n        \n\t\t\tid value = [model valueForKey:key];\n\t\t\tif (value) {\n\t\t\t\t[dict setValue:value forKey:key];\n\t\t\t}\n\t\t}\n\t\treturn dict;\n\t}\n\n#### 在 **jsonModelWithDictionary:** 方法中，基于KVC特性，把JSON转化成MOdel对象，在 **jsonModelWithModel:** 方法中，在运行时获取model的属性类型(runtime机制)，然后根据属性获取属性值(KVC机制)，然后把属性和值添加到字典中。即可实现Model转化成JSON字典对象。\n\n> 代码清单，接上，JSONModel.m\n\t\n\t#pragma mark -\n\t#pragma mark - NSCoding协议:解码\n\t- (id)initWithCoder:(NSCoder *)aDecoder {\n    \n\t\tif (self = [super init]) {\n        \n\t\t\tNSArray *properNames = [self getPropertyList];\n        \n\t\t\tfor (NSString *key in properNames) {\n            \n\t\t\t\tid varValue = [aDecoder decodeObjectForKey:key];\n\t\t\t\tif (varValue) {\n\t\t\t\t\t[self setValue:varValue forKey:key];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn self;\n\t}\n\t\n\t#pragma mark -\n\t#pragma mark - NSCoding协议:编码\n\t- (void)encodeWithCoder:(NSCoder *)aCoder {\n\t\tNSArray *properNames = [self getPropertyList];\n\t\tfor (NSString *key in properNames) {\n        \n\t\t\tid varValue = [self valueForKey:key];\n\t\t\tif (varValue)\n\t\t\t{\n\t\t\t\t[aCoder encodeObject:varValue forKey:key];\n\t\t\t}\n\t\t}\n\t}\n\n\t#pragma mark -\n\t#pragma mark - NSCopying协议\n\t- (id)mutableCopyWithZone:(NSZone *)zone {\n\t\t// subclass implementation should do a deep mutable copy\n\t\t// this class doesn't have any ivars so this is ok\n\t\tJSONModel *newModel = [[JSONModel allocWithZone:zone] init];\n\t\treturn newModel;\n\t}\n\n\t- (id)copyWithZone:(NSZone *)zone {\n\t\t// subclass implementation should do a deep mutable copy\n\t\t// this class doesn't have any ivars so this is ok\n\t\tJSONModel *newModel = [[JSONModel allocWithZone:zone] init];\n\t\treturn newModel;\n\t}\n\n***\n\n> 客户端代码\n\t\n\t// json转化成model 和 model 转化成 json\n\tMainInfo *info = [MainInfo jsonModelWithDictionary:dict];\n\tNSDictionary *dict = [MainInfo jsonModelWithModel:info];\n\t\n\t// 编码\n\tMainInfo *p = [[MainInfo alloc] init];\n\tp.name = @\"turkey\";\n\tNSString *documents = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];\n\tNSString *path = [documents stringByAppendingPathComponent:@\"main.archiver\"];//拓展名可以自己随便取\n\t[NSKeyedArchiver archiveRootObject:p toFile:path];\n\t    \n\t// 解码\n\tNSString *documents = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) lastObject];\n\tNSString *path = [documents stringByAppendingPathComponent:@\"main.archiver\"];\n\tMainInfo *mainInfo = [NSKeyedUnarchiver unarchiveObjectWithFile:path];\n\n### TODO\n\n#### 5. 对象组合\n\n#### 6. 工具类\n\n"
             },
             {
             "id": "1EC1F6D8-F6C3-449F-87BD-3B6BB3D1A128",
             "categoryId": 5,
             "userID": "9B7D73E9-9F92-4365-BC1D-7C7CBC4FF59F",
             "likeNum": 0,
             "author": "turkeyaa",
             "isGood": 0,
             "title": "vuejs教程",
             "viewNum": 1,
             "createTime": 1535079803,
             "collectNum": 0,
             "replyNum": 0,
             "content": "初次接触vue，刷完了堪称经典的vue官网文档+vue-router文档+vuex文档+vue-cli文档，然后就开始刷项目了。这篇文章总结了项目实践的一些思路。"
             },
             {
             "id": "372ACC10-EB99-4534-A5D2-2FCE47EDA97F",
             "categoryId": 5,
             "userID": "9B7D73E9-9F92-4365-BC1D-7C7CBC4FF59F",
             "likeNum": 0,
             "author": "turkeyaa",
             "isGood": 0,
             "title": "vuejs教程",
             "viewNum": 1,
             "createTime": 1535249301,
             "collectNum": 0,
             "replyNum": 0,
             "content": "初次接触vue，刷完了堪称经典的vue官网文档+vue-router文档+vuex文档+vue-cli文档，然后就开始刷项目了。这篇文章总结了项目实践的一些思路。"
             },
             {
             "id": "C15FB5D9-47C1-4FF3-8E5B-EE6839489B49",
             "categoryId": 1,
             "userID": "9B7D73E9-9F92-4365-BC1D-7C7CBC4FF59F",
             "likeNum": 1,
             "author": "turkeyaa",
             "isGood": 0,
             "title": "并发编程",
             "viewNum": 46,
             "createTime": 1531573928,
             "collectNum": 0,
             "replyNum": 2,
             "content": "---\nlayout: post\ntitle: 并发编程\ncategories: [技术]\ntags: [Objective-C]\ndescription:\n---\n\n\n> 在计算机科学中，并发处理(concurrent processing)是指同时执行多个逻辑控制流(在软件中实现的)。在计算机系统中，并发处理可以在从硬件层到应用层的多个层级中实现。在应用层使用并发处理，可以开发出以并行方式(in parallel)执行多个操作的应用程序，这些操作包括回应异步事件、访问I/O设备、提供网络服务以及进行并行运算等\n\n#### 1.1 并发编程的基本原则\n\n并发编程是一个含有许多概念和创意的广阔领域。因此，在学习这种技术前，了解一些基本术语和各种并发编程的设计概念及优点就非常重要。下面先理解下并发处理与顺序处理的区别。如图：\n\n![并发处理or顺序处理]({{ turkeyaa.github.io }}/assets/2017/blog_concurrent.png)\n\n并发处理就意味着同时执行多个任务。但实际上，在设计时希望利用并发机制的程序是否真的会并发执行多任务，取决于运行程序的计算机系统。这就引出了一个必须说明的差异，即并发计算(concurrent computing)和并行计算(parallel computing)的差异。从广义上将，并发计算与设计相关，而并行计算与硬件相关。\n\n> 并行计算 or 并发计算\n\n* 并行计算：指多个软件同时执行多个操作和任务。执行并行计算的能力直接取决于计算机硬件。当今的大多数计算机都拥有多个核心或多个CPU，使得它们能够执行多条指令。\n* 并发计算：指一个软件被设计和实现来同时执行多个操作或任务。如果你的软件是并发编程原则和机制设计并实现的，那么它的某些/所有组件就会根据计算机硬件的能力，以并发方式运行。因此，要发挥并发处理的优势，就必须以相应的方式设计和实现软件，并在能够支持并行处理的硬件上运行它\n\n> 并发编程 or 异步编程\n\n* 并发处理：是指同时处理多个逻辑控制流。\n* 异步处理：是一种对方法和函数进行异步(非阻塞)调用操作的高效机制。换言之，调用了方法后，在该方法被执行时，调用程序仍旧可以继续其处理过程。这种方式抽象化了基础实现机制，可以提高应用程序的响应性、系统的吞吐量等性能指标。可以通过多种设备实现异步处理，也可以通过使用并发编程API和服务来实现。\n\n#### 1.1.1 并发处理的优势\n\n以应用程序级并发处理方式开发程序，可以使程序同时执行多个操作。然而，这些功能并不是没有代价的，要实现这些功能，不仅需要有计算机硬件的支持，而且必须将并行处理思想融入到软件设计和实现过程之中。包括但不限于以下几条：\n\n1. 增加应用程序的吞吐量：因为并发处理会使程序同时处理多个任务，而应用程序的吞吐量就是指在一段时间内应用程序能够完成的任务数，所以并发处理会比顺序处理完成更多任务。\n2. 提高系统利用率：以并行方式执行多个任务，可以更集中、更高效地利用系统资源。\n3. 提供应用程序的整体响应性：以并发方式执行多个任务时，如果某个任务(如输入操作)正在等待，那么其他任务也可以继续运行，婴儿能够减少应用程序的整体闲置时间，提高应用程序的响应性。\n4. 更好地与问题领域契合：在对某些问题(如科学、数学和人工智能领域的)进行建模时，可以将它们创建为同时处理的任务集合。以并发编程方式处理这些模型是更自然、更优的选择。\n\n#### 1.1.2 实现并发处理\n\n在计算机系统中，实现并发处理的方式有很多。下面是几种常见的方式：\n\n1. 分布式计算：在这种并发处理方式中，多个任务会被分给多台通过网络相连的计算机执行，这些计算机通过消息传递来相互通信。\n2. 并行编程：在这种并发处理方式中，通常由多核CPU和可编程GPU进行大量的并行计算。\n3. 多进程：在这种并发处理方式中，多个任务会被分发给一台计算机中的多个进程，每个进程都拥有由操作系统管理的独立资源和地址空间。\n4. 多线程：在这种并发处理方式中，多个任务会与多个线程对应，这些线程会被配置为以并发方式执行。因为这些线程是在单个程序(进程)的环境中被执行的，所以它们会共享资源(如地址空间和内存等)。\n\n#### 1.2 并发处理带来的挑战\n\n正确的使用并发编程并不容易，主要的难点是进行同步操作和在并发执行的控制线程(即逻辑控制流)之间共享信息。在控制不同线程中的相关操作时需要实现同步，而要在线程之间进行通信就必须实现信息共享。\n\n可通过许多机制处理上述难题，其中最常用的两种是共享内存和消息传递。共享内存编程模式会实现共享状态，也就是说，多个线程都可以访问某些程序数据。当程序中的多个线程共同使用某个地址空间时，共享内存就成了信息共享方式的自然自选，既快速又高效。\n\n#### 1.2.1 共享数据\n\n共享内存模式需要一种机制来协调多个线程共用的数据。通常使用同步机制来实现这一目标，例如使用锁或判定条件。**锁** 是一种控制多线程间数据访问和资源共享的机制。线程获得共享资源的锁，对该资源执行操作，接着释放这个锁，然后其他线程才能访问该资源。**条件变量** 是一种同步机制，它使线程一直处于等待状态直到指定条件出现。条件变量通常是使用锁实现的。\n\n#### 1.2.2 锁带来的问题\n\n锁是最常见的控制机制，使用它可以控制多线程对共享数据的访问。锁实施一种互斥策略，从而避免受保护的数据和资源被多个线程同时访问。遗憾的是，在使用锁协调对共享数据的访问时，很可能引发死锁、或锁和资源匮乏问题，这些问题都会导致程序中断。\n\n![死锁]({{ turkeyaa.github.io }}/assets/2017/blog_lock.png)\n\n* 死锁：是指两个或多个线程相互阻塞的情况，每个线程都在等待其他线程释放锁，导致所有线程都一直处于等待状态。死锁的一个例子是循环等待。如上图\n* 活锁：是指一个线程因为要回应其他的一个或多个线程，而导致自身无法继续执行的情况。活锁的线程没有被阻塞，它将所有的计算时间用于回应其他线程，以恢复正常的操作\n* 资源匮乏：是指线程无法访问共享资源的情况，其原因是共享资源被其他线程占用。当一个或多个线程占用共享资源的时间过长时，就会引发这种问题。实际上，可以将活锁视为资源匮乏的一种形式。\n\n下面是一些防止出现这类问题的常用处理方式\n\n* 实现获取锁的总次序：确保进程按照固定次序获取和释放锁。\n* 防止出现保持和等待条件：使线程一次原子获取所有锁。这可以确保在任何时候每个线程都拥有一个锁，从而使程序获得了全局预防锁。这种处理方式消除了出现保持和等待情况的可能性，但可能会降低并发处理的效率，而且需要掌握线程代码的知识。\n* 提供优先权：使用提供试锁(trylock)或类似机制的锁，如果可以，获取锁。如果不行，返回一个合适的结果。这种处理方式会增加出现活锁的可能性，而且需要掌握代码如何使用锁的知识。\n* 设置等待超时：使用提供超时功能的锁，防止出现无限等待的情况。\n\n#### 1.2.3 消息传递\n\n在消息传递模式中，模型状态不是共享的，线程通过交换消息进行通信。这种处理方式使线程能够通过交换消息进行同步和通信。消息传递避免了互斥问题，并自然地与多核、多处理器系统契合。使用消息传递既可以执行同步通信，可以执行异步通信。\n\n在进行同步消息传递时，发送者和接收者会直接连接；消息传递操作完成后，发送者和接收者会断开连接。\n\n异步消息传递通过队列传输消息，而不是在线程之间直接传递。因此，发送者和接收者并不会配对，发送者将消息发送给队列后也无需断开连接。\n\n![queue]({{ turkeyaa.github.io }}/assets/2017/blog_queue.png)\n\n#### 1.3 在 Objective-C 中实现并发编程\n\n* 语言特性：Objective-C语言有多个支持并发编程的特性。使用@synchronized指令可以在Objective-C代码中创建锁。使用atomic属性限定符可以对Objective-C属性进行线程安全的访问\n* 消息传递：Foundation框架中的NSObject类含有多个用于向其他线程发送消息的方法。这些方法会将目标线程运行循环中的消息添加到队列中，而且能够通过通过或异步方式执行。\n* 线程：Foundation框架提供了直接创建和管理线程的整套API。其中还包括用于多线程共享数据进行同步访问的Foundation框架API集。\n* 操作队列：这是基于Objective-C的消息传递机制，它通过异步设计方法实现并发编程\n* 分派队列：这些是基于C语言的一系列语言特性和运行时服务，用于通过异步和并发方式执行任务\n\n#### 1.4 语言特性\n\n@synchronized指令提供了在Objective-C代码中创建锁的简单机制，使并发线程能够同步访问共享状态。\n\n@synchronized指令后面带有一个放在圆括号中的唯一标识符，以及放在花括号中的受保护代码块。这个唯一标识符是一个用于区分受保护代码块的对象。如果有多个线程尝试使用想用的唯一标识符访问这个关键部分，那么这些线程中的某一个线程会先得到锁，而其他线程会被阻塞，直到得到锁的线程完成了对这个关键部分的操作为止。 \n\n```\n// 申明userName属性\n@property (nonatomic, copy) NSString *userName;\n\t\n// 可以这样修改属性值\n@synchronized (_userName) {\n\t// 关键部分 - 被该指令保护的代码\n\t_userName = @\"turkeyaa\";\n}\n```\n\nObjective-C语言还提供了一种用于对属性进行原子访问的特性。原子(atomic)是指不论属性是否被以并发方式访问，属性的访问方法永远都会设置/获取完整(一致性)值。\n\n```\n@property (atomic, copy) NSString *userName;\n```\n\n#### 1.5 消息传递\n\nFoundation框架中的NSObject类含有许多方法，这些方法使用消息传递模式，通过线程调用对象中的方法。可以是主线程或其他线程。\n\n```\n- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay inModes:(NSArray<NSRunLoopMode> *)modes;\n- (void)performSelector:(SEL)aSelector withObject:(nullable id)anArgument afterDelay:(NSTimeInterval)delay;\n......\n```\n\t\nNSObject类中的每个方法都会为接受对象中将被线程调用的方法设置选择器。该方法也叫做线程入口例程。选择器消息会在线程的运行循环中排队，而该方法会作为运行循环中的标准处理过程被线程执行。使用这些消息传递方法，可以设置为同步或异步方式调用线程。同步调用方法会阻塞当前线程，直到该方法执行完为止。因为这些方法是NSObject类定义的，所有NSObject类的所有子类都会拥有这些方法。\n\n> 代码清单 使用NSObject类中的performSelector:onThread: withObject:waitUntilDone: 异步调用线程secondaryThread中的downloadTask方法\n\t\n```\nProcessor *processor = [[Processor alloc] init];\n[processor performSelector:@selector(downloadTask) onThread:secondaryThread withObject:nil waitUntilDone:NO];\n```\n\t\n在创建线程时，可以配置它的部分运行时环境(如栈大小、本地线程存储空间、线程优先权等)。通过使用下列功能实现线程入口点例程：自动释放池、异常处理程序、运行循环。\n\nNSObject类中的performSelectorOnMainThread:方法通常用于，从次要线程对象向主线程对象返回值(如状态、计算结果等)。这样就在次要线程和主线程之间实现了通信。\n\n#### 1.6 线程\n\n线程是指在某个进程环境中执行的逻辑控制流。OS X和iOS操作系统为线程的创建、管理和执行提供了直接的支持。在应用层，Foundation框架提供了许多用于创建和管理线程的API，以及用于在并发线程之间同步共享数据访问的API集合\n\n#### 1.6.1 NSObject线程\n\n使用NSObject类中的performSelectorInBackground:withObject:方法，可以隐式地创建和启动用于执行对象中方法的新线城。该线程会作为后台次要线程立刻启动，而当前进程会立刻返回。这个方法提供了一种使用新后台线程执行对象中方法的简单机制。该线程实例是隐式创建的，因此无需直接使用API。应根据需要，通过自动释放此、异步处理器和运行时循环在方法中配置该线程的环境\n\n```\nProcessor *processor = [[Processor alloc] init];\n[processor performSelectorInBackground:@selector(downloadTask) withObject:nil];\n```\t\n\t\n#### 1.6.2 NSThread\n\nNSThread类提供了用于通过显式创建和管理线程的API。该类含有多个方法，使用这些方法可以创建和初始化NSThread对象、启动和停止线程、配置线程和查询线程及其执行环境\n\n> 下面是NSThread类中用于创建和初始化线程的API：\n\t\n```\ndetachNewThreadSelector:toTarget:withObject:\n\tintiWithTarget:selector:object:\n```\n\t\n该方法会创建新线程并调用接收者的入口点例程(即将该方法与它的选择器对应起来)。不同的是 **intiWithTarget:selector:object:** 方法会创建新线程，但不会启动该线程。当已初始化的线程开始执行接收者的入口点例程时，调用NSThread类的 **start** 方法启动该线程\n\n```\nNSThread *newThread = [[NSThread alloc] initWithTarget:self selector:@selector(downloadTask) object:nil];\n[newThread setThreadPriority:0.5];\n[newThread start];\n\t\n// 线程暂停5秒\n[NSThread sleepForTimeInterval:5.0];\n\t\n```\n\n#### 1.6.3 线程同步\n\nObjective-C平台提供了多种机制来管理共享状态是实现线程之间的同步。Foundation框架中含有一系列锁和条件变量API。\n\n#### 1. 锁\n\nFoundation框架中含有多个类(NSLock、NSRecursiveLock、NSConditionLock、NSDistributedLock)，使用这些类可以实现各种用于同步访问共享状态操作的锁。锁用于保护关键部分(即用于访问共享数据或资源的代码部分)，这些代码不允许多个线程以并发方式执行。\n\nNSLock类为并发编程实现了一种基本的互斥锁。它遵守NSLocking协议，并因此会实现分别用于获取和释放锁的 **lock** 和 **unlock** 方法。前面介绍过@synchronized，它是一种Objective-C语言特性，可以实现媲美NSLock类的互斥锁。主要区别：\n\n1. @synchronized指令隐式创建锁，而NSLock类的API直接创建锁\n2. @synchronized指令会隐式地为关键部分提供异常处理程序，而NSLock类没有提供这一功能\n\n> 代码清单 使用NSLock实例保护关键部分\n\t\n```\nNSLock *computeLock = [NSLock new];\n...\n[computeLock lock];\n\t\n// 关键部分\n...\n\t\n[computeLock unlock];\n```\n\t\nNSDistributedLock类定义了一个可由多台主机上的多个应用程序使用的锁，使用该锁可以控制对共享资源的访问操作。与NSLock类不同，NSDistributedLock实例没有实施互斥策略，而是在锁处于繁忙状态时发送报告，由使用锁的代码根据锁的状态适当地执行操作。下面的代码用一个文件的路径 /hello.lck 创建了分布锁，你可能会将该文件作为锁定系统对象。\n\n> 代码清单 使用NSDistributedLock实例控制对资源的访问\n\t\n```\nNSDistributedLock *fileLock = [NSDistributedLock lockWithPath:@\"/hello.lck\"];\n\t\n// 访问资源\n...\n// 解除对资源的锁定\n[fileLock unlock];\n```\t\n\t\nNSDistributedLock类没有遵守NSLocking协议。而且，因为这个锁是使用文件系统实现的，所以它必须显示释放。如果某个应用程序在拥有分布锁的情况下终止运行，那么其他客户端必须使用NSDistributedLock类中的 **breakLock** 方法才能解除这种锁定\n\nNSConditionLock类定义了一种只有在特定条件下才能获取和释放的锁，这个条件是由你定义的整数值。条件锁通常用于确保任务以指定的顺序执行，如线程之间的厂商-消费者处理流。\n\n> 代码清单 使用NSConditionLock实例控制对资源的访问\n\t\n```\nNSConditionLock *dataLock = [[NSConditionLock alloc] initWithCondition:NO];\n\t\n...\n// 获取锁(缓冲区中没有数据)\n[dataLock lock];\n// 将数据添加到缓冲区中\n\t\n...\n// 根据条件解锁(数据位于缓冲区中)\n[dataLock unlockWithCondition:YES];\n```\n\t\nNSRecursiveLock类定义了一种在不引起死锁的情况下，可以被同一个线程获取多次的锁。\n\n#### 2. 条件\n\n条件变量是一种锁，用于同步操作的执行顺序。尝试获取条件的线程会一直阻塞，直到另一个线程显式地向该条件发出信号(signla)为之。等待某个条件的线程也会一直阻塞，直到另一个线程显式的向该条件发出信号为之。Foundation框架中NSCondition类实现了一种条件变量。\n\n> 使用NSCondition实例同步对共享数据的消费者操作\n\t\n```\n@autoreleasepool {\n        \n\t// 获取条件锁并测试布尔条件\n\t[condition lock];\n\twhile (!self.dataAvailable) {\n\t\t[condition wait];\n\t}\n        \n\t// 数据处于可访问状态后，对数据进行处理(代码已省略)\n\t...\n        \n\t// 完成处理数据的操作，更新判断值和发送信号的条件\n\tself.dataAvailable = NO;\n\t[condition signal];\n        \n\t// 解除条件锁\n\t[condition unlock];\n}\n\n```\n\n#### 1.6.4 使用线程实现并发处理\n\n下面使用线程和这些同步机制创建一个执行并发处理的示例程序。\n\n> 代码清单 ConcurrentProcessor.h\n\t\n```\n@interface ConcurrentProcessor : NSObject\n\n@property (readwrite) BOOL isFinished;\n@property (readonly) NSInteger computeResult;\n\n- (void)computeTask:(id)data;\n\n@end\n\t\n```\n\t\n> 代码清单 \tConcurrentProcessor.m\n\t\n\t@interface ConcurrentProcessor ()\n\n\t@property (readwrite) NSInteger computeResult;\n\n\t@end\n\n\t@implementation ConcurrentProcessor\n\n\t{\n\t\tNSString *computeID;    // @synchronize 指令锁定的唯一对象\n\t\tNSUInteger computeTask; // 并行计算任务的计数\n\t\tNSLock *computeLock;    // 锁对象\n\t}\n\n\t- (id)init {\n\t\tif (self = [super init]) {\n\t\t\t_isFinished = NO;\n\t\t\t_computeResult = 0;\n\t\t\tcomputeLock = [NSLock new];\n\t\t\tcomputeID = @\"1\";\n\t\t\tcomputeTask = 0;\n\t\t}\n\t\treturn self;\n\t}\n\n\t- (void)computeTask:(id)data {\n\t\tNSAssert(([data isKindOfClass:[NSNumber class]]), @\"Not an NSNumber instance\");\n\t\tNSInteger computations = [data integerValue];\n\t\t@autoreleasepool {\n\t\t\t@try {\n\t\t\t\t// 获取所并增加活动任务的计数\n\t\t\t\tif ([[NSThread currentThread] isCancelled]) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t@synchronized (computeID) {\n\t\t\t\t\tcomputeTask++;\n\t\t\t\t}\n            \n\t\t\t\t// 获取所并执行关键代码部分中的计算操作\n\t\t\t\t[computeLock lock];\n\t\t\t\tif ([[NSThread currentThread] isCancelled]) {\n\t\t\t\t\t[computeLock unlock];\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tNSLog(@\"Performing computations\");\n\t\t\t\tfor (NSInteger ii=0; ii<computations; ii++) {\n\t\t\t\t\tself.computeResult++;\n\t\t\t\t}\n\t\t\t\t[computeLock unlock];\n            \t\n\t\t\t\t[NSThread sleepForTimeInterval:1.0];\n            \n\t\t\t\t// 减少活动任务数，如果数量为0，则更新标志位\n\t\t\t\t@synchronized (computeID) {\n\t\t\t\t\tcomputeTask--;\n\t\t\t\t\tif (!computeTask) {\n\t\t\t\t\t\tself.isFinished = YES;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} @catch (NSException *exception) {\n            \n\t\t\t} @finally {\n            \n\t\t\t}\n\t\t}\n\t}\n\n\t@end\n\t\n> 代码清单，客户端代码，在viewDidLoad中添加下面代码\n\t\n\tConcurrentProcessor *processor = [[ConcurrentProcessor alloc] init];\n    \n\t[processor performSelectorInBackground:@selector(computeTask:) withObject:[NSNumber numberWithInteger:5]];\n\n\t[processor performSelectorInBackground:@selector(computeTask:) withObject:[NSNumber numberWithInteger:10]];\n\n\t[processor performSelectorInBackground:@selector(computeTask:) withObject:[NSNumber numberWithInteger:20]];\n\n\twhile (!processor.isFinished);\n    \n\tNSLog(@\"Computation result5 = %d\",processor.computeResult);\n\n> 客户端输出\n\n![线程同步]({{ turkeyaa.github.io }}/assets/2017/concurrent/concurrent_result.png)\n\n\n#### 1.7 操作和操作队列\n\n#### 1.7.1 操作\n\nNSOperation、NSBlockOperation和NSInvocationOperation类用于管理一个或多个操作、代码以及单个任务关联数据的并行执行过程。操作队列是指提供并行执行任务功能的Objective-C对象。每个任务(即操作)都定义了需要执行的程序和与之相关的数据，而且会被封装在块对象或NSOperation类的具体子类中。NSOperation是一个抽象类，用于封装单个任务和代码和相关数据。在处理并行任务时，具体子类通常只需重写主要方法。至少必须重写 **start** 、**inConcurrent** 、 **isExecuting** 和 **isFinished** 方法。\n\n> 下面的语句创建了一个名为greetingOp的NSBlockOperation实例\n\t\n\tNSBlockOperation *greetingOp = [NSBlockOperation blockOperationWithBlock:^{\n        \n        NSLog(@\"Hello, World!\");\n    }];\n    \n> 还可以使用addExecutionBlock:方法，为NSBlockOperation实例添加额外的块兑现\n\t\n\t[greetingOp addExecutionBlock:^{\n        NSLog(@\"Goodbye\");\n    }];\n    \n\n> 可以使用NSInvocationOperation类初始化实例。然后调用选择器 **hello:** ，并带有NSNumber参数值：\n\t\n\tNSInvocationOperation *invokeOp = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(hello:) object:@(20)];\n\t\n还可以实现自定义操作类。自定义操作类是NSOperation类的子类，至少必须实现用于执行任务的main方法。自定义操作还可以提供下列功能：\n\n* 自定义的初始化方法\n* 自定义的辅助方法(通过main方法调用)\n* 用于设置数据值和访问操作结果的访问器方法\n* 使自定义操作类遵守NSCoding协议的方法(以支持归档对象的功能)\n\n操作对象可以支持各种并发编程功能：\n\n* 在操作对象之间建立依赖关系，从而控制它们的执行顺序\n* 创建在操作的主任务完成后执行的完成语句块\n* 获取操作的执行状态\n* 为操作队列中的操作设置优先权\n* 取消操作\n\n操作对象是通过调用其 **start** 方法执行的。该方法的默认实现会同步执行操作的任务。要实现并发编程的话，可以把操作对象添加到操作队列中执行。\n\n#### 1.7.2 操作队列\n\n操作队列是一种提供并发执行操作能力的机制。Foundation框架中的NSOperationQueue类就是操作队列的一个Objective-C实现。可以将操作作为快对象或NSOperation类的某个子类的实例，添加到NSOperationQueue实例中。操作队列管理操作的执行情况。因此，NSOperationQueue类含有多个方法，使用这些方法可以管理操作队列中的操作、管理正在运行的操作的数量、暂停操作和检索特定的操作队列。\n\n> 向操作队列中添加一个块对象和一个操作\n\t\n\tNSOperationQueue *queue = [[NSOperationQueue alloc] init];\n\t\n\t// 一个块对象\n\t[queue addOperationWithBlock:^{\n        for (NSInteger nn=0; nn<1000; nn++) {\n            NSLog(@\"NN = %d ---- %@\",nn,[NSThread currentThread]);\n        }\n    }];\n    \n    // 一个操作\n    NSBlockOperation *greetingOp = [NSBlockOperation blockOperationWithBlock:^{\n        \n        NSLog(@\"Hello, World!\");\n    }];\n    [queue addOperation:greetingOp];\n    \n将操作添加到队列中后，它会呆在队列中，直到被显式取消或执行完成它的任务为之。通过调用NSOperation对象的 **cancel** 方法或者操作队列中的 **cancelAllOperations** 方法，可以取消操作队列中的NSOperation对象\n\n操作队列中操作的执行顺序取决于操作的优先级和操作对象之间的依赖关系。操作队列中的每个操作都是由独立线程执行的。\n\n#### 1.7.3 实现并发操作 --- 自定义NSOperation子类来实现\n\n> 代码清单，GreetingOperation类继承自NSOperation类，GreetingOperation.m\n\n```\n\n@implementation GreetingOperation\n\n{\n    BOOL finished;\n    BOOL executing;\n}\n\n- (id)init {\n    if (self = [super init]) {\n        executing = NO;\n        finished = NO;\n    }\n    return self;\n}\n\n- (void)start {\n    // 如果操作被取消了就返回结果\n    if ([self isCancelled]) {\n        [self willChangeValueForKey:@\"isFinished\"];\n        finished = YES;\n        [self didChangeValueForKey:@\"isFinished\"];\n        return;\n    }\n    \n    // 使用独立线程执行main方法中的操作\n    [self willChangeValueForKey:@\"isExecuting\"];\n    [NSThread detachNewThreadSelector:@selector(main) toTarget:self withObject:nil];\n    executing = YES;\n    [self didChangeValueForKey:@\"isExecuting\"];\n}\n\n- (void)main {\n    @autoreleasepool {\n        @try {\n            if (![self isCancelled]) {\n                NSLog(@\"Current Thread = %@\",[NSThread currentThread]);\n                NSLog(@\"Hello, World!\");\n                [NSThread sleepForTimeInterval:3.0];\n                NSLog(@\"Goodbye, World!\");\n                \n                [self willChangeValueForKey:@\"isFinished\"];\n                [self willChangeValueForKey:@\"isExecuting\"];\n                executing = NO;\n                finished = YES;\n                [self didChangeValueForKey:@\"isFinished\"];\n                [self didChangeValueForKey:@\"isExecuting\"];\n            }\n        } @catch (NSException *exception) {\n            \n        } @finally {\n            \n        }\n    }\n}\n\n- (BOOL)isConcurrent {\n    return YES;\n}\n\n- (BOOL)isExecuting {\n    return executing;\n}\n\n- (BOOL)isFinished {\n    return finished;\n}\n\n\n@end\n\n```\n\n> 客户端代码\n\t\n\tConcurrentOperation *op = [[ConcurrentOperation alloc] init];\n\t[op start];\n\n#### 1.7.4 实现并发操作 --- 使用操作队列实现并发处理\n\n> 同上，修改客户端代码\n\t\n\tConcurrentOperation *op = [[ConcurrentOperation alloc] init];\n\tNSOperationQueue *queue = [[NSOperationQueue alloc] init];\n\t[queue addOperation:op];\n\t[queue waitUntilAllOperationsAreFinished];\n\n#### 1.8 分派队列\n\nGrand Central Dispatch(GCD)是一个集合，它含有语言特性、基于C语言的API、以及支持使用分派队列执行任务的系统增强功能。使用GCD分派队列可以同步或异步地执行代码，以及串行或并行的执行任务。与操作队列一样，分派队列也比线程更易于使用，执行异步或并发任务更高效。\n\n> 客户端代码，在viewDidLoad中添加\n\t\n\t// 创建顺序队列和分组\n\tdispatch_queue_t serialQueue = dispatch_queue_create(\"com.ds.turkey\", DISPATCH_QUEUE_SERIAL);\n    \n\tdispatch_group_t group = dispatch_group_create();\n    \n\t// 向队列中添加任务\n\tdispatch_group_async(group, serialQueue, ^{\n\t\tNSLog(@\"First task\");\n\t\t[NSThread sleepForTimeInterval:2];\n\t\tNSLog(@\"First task over\");\n\t});\n\tdispatch_group_async(group, serialQueue, ^{\n\t\tNSLog(@\"Second task\");\n\t\t[NSThread sleepForTimeInterval:2];\n\t\tNSLog(@\"Second task over\");\n\t});\n    \n\t// 等待，当分组中的所有任务都完成时\n\t// 作其他处理\n\tdispatch_group_notify(group, serialQueue, ^{\n\t\tNSLog(@\"所有任务都已经完成\");\n\t});\n\tNSLog(@\"Over\");\n\t\n\t// 结果为：\n\t2017-05-27 09:25:35.372 Test_concurrent[3126:74272] Over\n\t2017-05-27 09:25:35.372 Test_concurrent[3126:74358] First task\n\t2017-05-27 09:25:37.375 Test_concurrent[3126:74358] First task over\n\t2017-05-27 09:25:37.376 Test_concurrent[3126:74358] Second task\n\t2017-05-27 09:25:39.377 Test_concurrent[3126:74358] Second task over\n\t2017-05-27 09:25:39.378 Test_concurrent[3126:74358] 所有任务都已经完成\n\t\n这段代码使用GCD API创建并以异步方式分派了3个串行执行的任务，从而协调了它们的执行次序，防止了它们对共享数据进行并发访问。最后 **dispatch_group_async** 函数监听任务是否完成，可以作出对结果的处理(更新界面)。"
             },
             {
             "id": "D3A73F78-0166-41C3-B7BA-3C03891E755A",
             "categoryId": 4,
             "userID": "9B7D73E9-9F92-4365-BC1D-7C7CBC4FF59F",
             "likeNum": 1,
             "author": "turkeyaa",
             "isGood": 0,
             "title": "svn使用",
             "viewNum": 22,
             "createTime": 1531627301,
             "collectNum": 1,
             "replyNum": 5,
             "content": "#### 1、 将文件checkout到本地目录\n* svn checkout PATH（path是服务器上的目录）\n* 例如：svn checkout svn://192.168.1.1/pro/domain\n* 简写：svn co\n\n#### 2、往版本库中添加新的文件\n* svn add file\n* 例如：svn add test.php(添加test.php)\n* svn add *.php(添加当前目录下所有的php文件)\n\n#### 3、将改动的文件提交到版本库\n* svn commit -m \"LogMessage\"\n* 例如：svn commit -m \"add test file for my test\" test.php\n* 简写：svn ci\n\n#### 4、加锁/解锁\n* svn lock -m \"LockMessage\" [--force] PATH\n* 例如：svn lock -m \"lock test file\" test.php\n* svn unlock PATH\n\n#### 5、更新到某个版本\n* svn update\n* svn update -r 200 test.php(将版本库中的文件test.php还原到版本200)\n* svn update test.php(更新，于版本库同步。如果在提交的时候提示过期的话，是因为冲突，需要先update，修改文件，然后清除svn resolved，最后再提交commit)\n* 简写：svn up\n\n#### 6、查看文件或者目录状态\n* svn status path（目录下的文件和子目录的状态，正常状态不显示）\n* 【?：不在svn的控制中；M：内容被修改；C：发生冲突；A：预定加入到版本库；K：被锁定】\n* svn status -v PATH (显示文件和子目录状态)\n* 第一列保持相同，第二列显示工作版本号，第三和第四列显示最后一次修改的版本号和修改人。\n* 注：svn status、svn diff和 svn revert这三条命令在没有网络的情况下也可以执行的，原因是svn在本地的.svn中保留了本地版本的原始拷贝。\n* 简写：svn st\n\n#### 7、删除文件\n* svn delete path -m \"delete test fle\"\n* 例如：svn delete svn://192.168.1.1/pro/domain/test.php -m \"delete test file\"\n* 或者直接svn delete test.php 然后再svn ci -m 'delete test file‘\n* 简写：svn (del, remove, rm)\n\n#### 8、查看日志\n* svn log path\n* 例如：svn log test.php 显示这个文件的所有修改记录，及其版本号的变化\n\n#### 9、查看文件详细信息\n* svn info path\n* 例如：svn info test.php\n\n#### 10、比较差异\n* svn diff path(将修改的文件与基础版本比较)\n* 例如：svn diff test.php\n* svn diff -r m:n path(对版本m和版本n比较差异)\n* 例如：svn diff -r 200:201 test.php\n* 简写：svn di\n\n#### 11、合并主干上的最新代码到分之上\n* cd ~/Desktop/svn/treatment/Branch/branch_001\n* svn merge svn://192.168.0.112/ios/common/treatment/Trunk/trunk_001\n* 可以先预览该操作：svn mergeinfo svn://192.168.0.112/ios/common/treatment/Trunk/trunk_001 --show-revs eligible\n\n#### 12、分之合并到主干，合并完成需要删除分之\n* cd trunk/trunk_001\n* svn merge --reintegrate svn://192.168.0.112/ios/common/treatment/branch/branch_001\n\n#### 13、版本库下的文件和目录列表\n* svn list PATH\n* 显示path目录下的所有属于版本库的文件和目录\n* 简写：svn ls\n\n#### 14、创建纳入版本控制下的新目录\n* svn mkdir: 创建纳入版本控制下的新目录。\n* 用法1: mkdir PATH  \n* 用法2: mkdir URL\n         \n#### 15、恢复本地修改\n* svn revert: 恢复原始未改变的工作副本文件 (恢复大部份的本地修改)。revert:\n* 用法: revert PATH\n* svn revert -R ~/Users/turkey/Desktop/RoomCureFun/\n* 注意: 本子命令不会存取网络，并且会解除冲突的状况。但是它不会恢复被删除的目录\n\n#### 16、代码库URL变更\n* svn switch (sw): 更新工作副本至不同的URL。\n* 用法1: switch URL [PATH]\n* 用法2: switch --relocate FROM TO [PATH...]\n* 更新你的工作副本，映射到一个新的URL，其行为跟“svn update”很像，也会将\n     服务器上文件与本地文件合并。这是将工作副本对应到同一仓库中某个分支或者标记的\n     方法。\n* 改写工作副本的URL元数据，以反映单纯的URL上的改变。当仓库的根URL变动\n    (比如方案名或是主机名称变动)，但是工作副本仍旧对映到同一仓库的同一目录时使用\n    这个命令更新工作副本与仓库的对应关系。\n\n#### 17、解决冲突\n* svn resolved: 移除工作副本的目录或文件的“冲突”状态。\n* 用法: resolved PATH\n* 注意: 本子命令不会依语法来解决冲突或是移除冲突标记；它只是移除冲突的相关文件，然后让 PATH 可以再次提交。\n\n#### 18、输出指定文件或URL的内容。\n* svn cat 目标[@版本]...如果指定了版本，将从指定的版本开始查找。\n* svn cat -r PREV filename > filename (PREV 是上一版本,也可以写具体版本号,这样输出结果是可以提交的)\n\n#### 19、创建分之\n* svn cp URL1(主干url) URL2(分之url) -m\"commit log\"\n* 用法: svn cp svn://192.168.0.1/ios/NewResource svn://192.168.0.1/ios/tag1.2 -m\"添加分之\"\n\n#### 20、删除分之\n* svn rm URL(分之url) -m\"commit log\"\n* svn rm svn://192.168.0.1/ios/tag1.2 -m\"删除分之\"\n\n#### 21、同步分之\n* svn co URL(主干url)\n* cd ~/tag1.2\n* svn merge URL(主干url) URL(分之url)\n* svn ci -m\"commit log\"\n* svn cp URL(主干url) URL(分之url) -m\"commit log\"\n\n#### 22、合并\n* svn co URL(目标url)\n* cd ~/wc\n* svn merge （基线版本tag）URL  （上线tag）URL\n* svn ci -m \"commit log\"\n* svn cp （合并目标）URL （上线tag_MERGE_的tag对应）URL -m\"commit log\"\n* svn cp svn://192.168.0.112/ios/common/treatment/Branch/Product svn://192.168.0.112/ios/common/treatment/Trunk/Product -m\"合并到1.9.3 分之\"\n\n#### 23、更新到分之\n* svn switch URL(分之url)\n* svn switch svn://192.168.0.1/ios/tag1.2\n\n#### 24、svn cleanup\n\n#### 25、svn import\n\n* 把未版本化得文件树，复制到资料库的快速方法\n* svn import myTree svn://192.168.0.1/ios/tag1.2 \n\n#### 26、svn 改名\n* svn mv myTreeOne myTreeTwo\n* svn commit -m\"修改名称\"\n\n#### 27、svn info\n* 查看当前工作副本所在 URL\n* svn info\n\n#### 28、svn add \n* 添加带问号的文件\n* svn add Template/APIs/Exam\n\n#### 29. 添加所有.a文件\n* find . -name \"*.a\" | xargs svn add\n\n#### 30. 批量删除 .svn文件 - 方式一\n* find . -name .svn -exec rm -rf {} \n\n#### 31. 批量删除 .svn 文件 - 方式二\n* find . -type d -name \".svn\"|xargs rm -rf\n\n#### 32. 批量删除文件[!]（!已经删除但是还未标记成从库中除去）\n* svn status|grep ! |awk '{print $2}'|xargs svn del\n\n#### 33. 批量添加文件[?]\n* svn status|grep ? |awk '{print $2}'|xargs svn add"
             }
             ]
}
